{"ast":null,"code":"\"use strict\";\n\nconst Cursor = require(\"./cursor\");\nconst Fragment = require(\"./fragment\");\nconst ops = require(\"./ops\");\nconst PDF = require(\"./object\");\nconst Readable = require(\"readable-stream\");\nconst {\n  v4: uuidv4\n} = require(\"uuid\");\nconst util = require(\"./util\");\nconst ContentChunk = require(\"./content\");\nconst ExternalDocument = require(\"./external\");\nconst Font = require(\"./font/base\");\nconst version = require(\"../package.json\").version;\n\n// constants\nconst RESOLVE = Promise.resolve();\nclass Document extends Readable {\n  constructor(opts) {\n    if (!opts) {\n      opts = {};\n    }\n\n    // readable stream options\n    super({\n      highWaterMark: opts.highWaterMark || 16384 // 16kB\n    });\n\n    this.version = \"1.6\";\n    this.info = Object.assign({}, opts.properties, {\n      id: uuidv4()\n    });\n    this.width = opts.width || 595.296;\n    this.height = opts.height || 841.896;\n    this._nextObjectId = 1;\n    this._xref = new PDF.Xref();\n    this._reading = false; // wheater someone is reading data from the underlying Readable\n    this._length = 0; // keeps track of the total document length (in byte)\n\n    // header\n    const header = `%PDF-${this.version}\\n` +\n    // The PDF format mandates that we add at least 4 commented binary characters\n    // (ASCII value >= 128), so that generic tools have a chance to detect\n    // that it's a binary file\n    \"%\\xFF\\xFF\\xFF\\xFF\\n\\n\";\n\n    // a backlog of pending operations\n    this._pending = [() => this._write(header)];\n    // this is the current operation that is executed (operations are executed sequentially)\n    this._pending.current = null;\n\n    // init default styling opts\n    this.defaultFont = opts.font || require(\"../font/Helvetica\");\n    this.defaultFontSize = opts.fontSize || 11;\n    this.defaultColor = opts.color && util.colorToRgb(opts.color) || [0, 0, 0];\n    this.defaultLineHeight = opts.lineHeight || 1.15;\n    if (!Font.isFont(this.defaultFont)) {\n      throw new TypeError(\"opts.font must be set to a valid default font\");\n    }\n\n    // create document and page font dict\n    this._fonts = {};\n    this._xobjects = {};\n    this._pageFonts = {};\n    this._annotations = [];\n\n    // these properties are used to keep track of used Font and Image objects and assign ids to\n    // them in a document-scoped way\n    this._aliases = new AliasGenerator();\n    this._mapping = new WeakMap();\n\n    // a page could consist out of multiple content chunks, which are keept track of using the\n    // following properties\n    this._currentContent = null;\n    this._contents = [];\n    this._contentObjCreator = null;\n\n    // this array can be used to register callbacks that are executed when finalizing the document\n    // e.g. rendering the total page count\n    this._finalize = [];\n    this._header = this._footer = this._template = null;\n\n    // init cursor\n    // TODO: test for valid values\n    const padding = opts.padding >= 0 ? opts.padding : 20;\n    this.paddingTop = util.defaults(opts.paddingTop, padding);\n    this.paddingBottom = util.defaults(opts.paddingBottom, padding);\n    this.paddingLeft = util.defaults(opts.paddingLeft, padding);\n    this.paddingRight = util.defaults(opts.paddingRight, padding);\n    this._cursor = new Cursor(this.width - this.paddingLeft - this.paddingRight, this.height - this.paddingTop - this.paddingBottom,\n    // width, height\n    this.paddingLeft, this.height - this.paddingTop) // x, y\n    ;\n\n    // init pages catalog\n    this._pages = new PDF.Array();\n    this._pagesObj = new PDF.Object(\"Pages\");\n    this._registerObject(this._pagesObj);\n\n    // init destinations name tree\n    this._destinations = new PDF.NameTree();\n\n    // init outlines hierarchy\n    this._outlines = [];\n\n    // init color space\n    this._colorSpace = new PDF.Object();\n    const iccProfile = require(\"./sRGB_IEC61966-2-1_black_scaled\") + \"~>\";\n    this._colorSpace.content = \"stream\\n\" + iccProfile + \"\\nendstream\\n\";\n    this._colorSpace.prop(\"Length\", iccProfile.length);\n    this._colorSpace.prop(\"N\", 3);\n    this._colorSpace.prop(\"Alternate\", \"DeviceRGB\");\n    // this._colorSpace.prop('Filter', new PDF.Array([\n    //   new PDF.Name('ASCII85Decode'), new PDF.Name('FlateDecode')\n    // ]))\n    this._colorSpace.prop(\"Filter\", new PDF.Name(\"ASCII85Decode\"));\n    this._registerObject(this._colorSpace);\n    this._currentColorSpace = \"/CS1\";\n\n    // start to work the _pending queue\n    this._next();\n    Fragment.prototype._init.call(this, this, this);\n  }\n\n  /// private API\n\n  _next() {\n    // return if there is already an operation worked on\n    if (this._pending.current) {\n      return this._pending.current;\n    }\n\n    // variables used to traverse the nested queue\n    let parent = this._pending;\n    let next = parent[0];\n\n    // if there is nothing in the queue, we are done here\n    if (!next) {\n      return RESOLVE;\n    }\n\n    // the operation queue is a nested array, e.g.: [op1, [op2, op3, [ op4 ]], op5]\n    // it is therefore necessary traverse the first element until the first non array element\n    // is encountered\n    while (Array.isArray(next)) {\n      // if the first element is an empty array, remove it and start over\n      if (next.length === 0) {\n        parent.shift();\n        return this._next();\n      }\n      parent = next;\n      next = next[0];\n    }\n\n    // remove next from the queue\n    parent.shift();\n\n    // TODO: still necessary?\n    // if (!next) {\n    //   return this._next()\n    // }\n\n    // return and set the current operation that is being executed\n    return this._pending.current = next().then(() => {\n      // once the execution finished, continue in the queue\n      this._pending.current = null;\n      return this._next();\n    });\n  }\n\n  // This is method is used by Node.js stream.Readable class, which we inherit from.\n  // The method is called, if data is available from the resource, which means that we should\n  // start pushing data into the read queue (using `this.push(dataChunk)`). It should continue\n  // reading from the resoruce and pushing data until `this.push()` return `false`. Only when it\n  // is called again aft it has stopped should it resume pushing additional data onto the\n  // read queue.\n  _read( /* size */\n  ) {\n    this._reading = true;\n    this.emit(\"read\");\n  }\n\n  // This method is used to push data onto the read queue. If the Readable stream is currently\n  // not read from, the writing is postponed.\n  _write(chunk) {\n    if (this._reading) {\n      if (!this.push(chunk, \"binary\")) {\n        this._reading = false;\n      }\n      this._length += chunk.length;\n      return RESOLVE;\n    } else {\n      return new Promise(resolve => {\n        this.once(\"read\", () => {\n          resolve(this._write(chunk));\n        });\n      });\n    }\n  }\n  _useFont(font) {\n    let alias;\n    if (this._mapping.has(font)) {\n      alias = this._mapping.get(font);\n      // if the alias exists but is now blocked (e.g. because of having set a new template with\n      // colliding aliases), remove the mapping and unset the alias to force creation of a new one\n      if (this._aliases.isBlocked(alias)) {\n        this._mapping.delete(font);\n        alias = undefined;\n      }\n    }\n    if (!alias) {\n      alias = new PDF.Name(this._aliases.next(\"F\"));\n      this._mapping.set(font, alias);\n      const fontObj = new PDF.Object(\"Font\");\n      this._fonts[alias] = {\n        f: font.instance(),\n        o: fontObj\n      };\n      this._registerObject(fontObj);\n    }\n    if (this._currentContent && !(alias in this._currentContent._fonts)) {\n      this._currentContent._fonts[alias] = this._fonts[alias].o.toReference();\n    }\n    return alias;\n  }\n  _fontAlias(instance) {\n    return this._useFont(instance.parent);\n  }\n  _fontInstance(font) {\n    return this._fonts[this._useFont(font)].f;\n  }\n  _useXObject(xobj) {\n    let alias;\n    if (this._mapping.has(xobj)) {\n      alias = this._mapping.get(xobj);\n      // if the alias exists but is now blocked (e.g. because of having set a new template with\n      // colliding aliases), remove the mapping and unset the alias to force creation of a new one\n      if (this._aliases.isBlocked(alias)) {\n        this._mapping.delete(xobj);\n        alias = undefined;\n      }\n    }\n    if (!alias) {\n      alias = new PDF.Name(this._aliases.next(\"X\"));\n      this._mapping.set(xobj, alias);\n      const xobjObjs = [];\n      for (let i = 0; i < xobj.xobjCount; ++i) {\n        const xobjObj = new PDF.Object(\"XObject\");\n        this._registerObject(xobjObj);\n        xobjObjs.push(xobjObj);\n      }\n      this._xobjects[alias] = {\n        x: xobj,\n        o: xobjObjs\n      };\n    }\n    if (this._currentContent && !(alias in this._currentContent._xobjects)) {\n      for (let i = 0; i < this._xobjects[alias].o.length; ++i) {\n        this._currentContent._xobjects[alias + \".\" + i] = this._xobjects[alias].o[i].toReference();\n      }\n    }\n    const aliases = [];\n    for (let i = 0; i < this._xobjects[alias].o.length; ++i) {\n      aliases.push(alias + \".\" + i);\n    }\n    return aliases;\n  }\n  async _startPage() {\n    if (this._currentPage) {\n      throw new Error(\"There is already a started page\");\n    }\n    const page = this._currentPage = new PDF.Object(\"Page\");\n    this._pages.push(page.toReference());\n    if (this._template) {\n      const taken = {};\n      for (const alias in this._template.colorSpaces) {\n        taken[alias] = null;\n      }\n      let i = 1;\n      for (1; (\"/CS\" + i in taken); ++i) {}\n      this._currentColorSpace = \"/CS\" + i;\n    } else {\n      this._currentColorSpace = \"/CS1\";\n    }\n    await this._startContentObject();\n    if (this._header) {\n      let chunk = \"\";\n      for (const i in this._header._objects) {\n        const obj = this._header._objects[i];\n        const alias = new PDF.Name(this._aliases.next(\"H\"));\n        this._currentContent._xobjects[alias] = obj.toReference();\n        chunk += ops.Do(alias);\n      }\n      await this._write(chunk);\n      await this._header._render();\n    }\n    if (this._footer) {\n      let chunk = \"\";\n      for (const i in this._footer._objects) {\n        const obj = this._footer._objects[i];\n        const alias = new PDF.Name(this._aliases.next(\"F\"));\n        this._currentContent._xobjects[alias] = obj.toReference();\n        chunk += ops.Do(alias);\n      }\n      await this._write(chunk);\n      await this._footer._render();\n    }\n    this._cursor.reset();\n    if (this._header) {\n      this._cursor.y -= this._header.height;\n    }\n    if (this._footer) {\n      this._cursor.bottomOffset = this._footer.height;\n    }\n  }\n  async _endPage() {\n    if (!this._currentPage) {\n      return;\n    }\n    await this._endContentObject();\n    const fonts = new PDF.Dictionary({});\n    const xobjects = new PDF.Dictionary({});\n    for (const content of this._contents) {\n      for (const alias in content._fonts) {\n        fonts.add(alias, content._fonts[alias]);\n      }\n      for (const alias in content._xobjects) {\n        xobjects.add(alias, content._xobjects[alias]);\n      }\n    }\n    const page = this._currentPage;\n    page.prop(\"Parent\", this._pagesObj.toReference());\n    const colorSpace = new PDF.Dictionary({\n      [this._currentColorSpace]: new PDF.Array([new PDF.Name(\"ICCBased\"), this._colorSpace.toReference()])\n    });\n    const resources = new PDF.Dictionary({\n      ColorSpace: colorSpace,\n      ProcSet: new PDF.Array([new PDF.Name(\"PDF\"), new PDF.Name(\"Text\"), new PDF.Name(\"ImageB\"), new PDF.Name(\"ImageC\"), new PDF.Name(\"ImageI\")]),\n      Font: fonts,\n      XObject: xobjects\n    });\n    page.prop(\"Resources\", resources);\n    if (this._annotations.length > 0) {\n      page.prop(\"Annots\", new PDF.Array(this._annotations));\n      this._annotations = [];\n    }\n    const contents = this._contents.map(c => c._object.toReference());\n    page.prop(\"Contents\", new PDF.Array(contents));\n    if (this._template) {\n      contents.unshift.apply(contents, this._template.contents);\n      for (const alias in this._template.colorSpaces) {\n        colorSpace.dictionary[alias] = this._template.colorSpaces[alias];\n      }\n      for (const alias in this._template.fonts) {\n        fonts.dictionary[alias] = this._template.fonts[alias];\n      }\n      for (const alias in this._template.xobjects) {\n        xobjects.dictionary[alias] = this._template.xobjects[alias];\n      }\n      const extGStates = new PDF.Dictionary({});\n      for (const alias in this._template.extGStates) {\n        extGStates.dictionary[alias] = this._template.extGStates[alias];\n      }\n      if (extGStates.length > 0) {\n        resources.set(\"ExtGState\", extGStates);\n      }\n      const shadings = new PDF.Dictionary({});\n      for (const alias in this._template.shadings) {\n        shadings.dictionary[alias] = this._template.shadings[alias];\n      }\n      if (shadings.length > 0) {\n        resources.set(\"Shading\", shadings);\n      }\n    }\n    await this._writeObject(page);\n    this._currentContent = this._currentPage = null;\n    this._contents.length = 0;\n    if (this._template && this._template.firstPageOnly) {\n      this._template = null;\n    }\n  }\n  async _pageBreak( /* level */\n  ) {\n    if (!this._currentPage) {\n      await this._startPage();\n    }\n    await this._cursor.reset();\n    await this._endPage();\n    await this._startPage();\n  }\n  async _startContentObject(obj, force) {\n    // do not create new content object, if current content object is still empty\n    // 16 = /CS1 CS\n    //      /CS1 cs\n    if (!force && this._length - 16 == this._contentStart) {\n      return this._currentContent;\n    }\n    if (this._currentContent) {\n      await this._endContentObject();\n    }\n    if (this._contentObjCreator) {\n      obj = this._contentObjCreator();\n    }\n    const content = this._currentContent = new ContentChunk(this, obj);\n    this._contents.push(content);\n    this._xref.add(content._object.id, {\n      offset: this._length,\n      obj: content._object\n    });\n    let chunk = content._object.id + \" \" + content._object.rev + \" obj\\n\" + content._object.properties.toString() + \"\\n\" + \"stream\\n\";\n    this._contentStart = this._length + chunk.length;\n\n    // set color space\n    chunk += ops.CS(this._currentColorSpace) + ops.cs(this._currentColorSpace);\n    await this._write(chunk);\n    return content;\n  }\n  async _endContentObject() {\n    if (!this._currentContent) {\n      return;\n    }\n    this._currentContent._length.content = this._length - this._contentStart - 1;\n    if (this._currentContent._length.content < 0) {\n      this._currentContent._length.content = 0;\n    }\n    const chunk = \"endstream\\nendobj\\n\\n\";\n    await this._write(chunk);\n    await this._writeObject(this._currentContent._length);\n    this._currentContent = null;\n  }\n  _registerObject(object, force) {\n    if (object instanceof PDF.Stream) {\n      object = object.object;\n    }\n    if (!force && object.id) {\n      return;\n    }\n    object.id = this._nextObjectId;\n    this._nextObjectId++;\n  }\n  _writeObject(object) {\n    if (object instanceof PDF.Stream) {\n      object = object.object;\n    }\n    if (!object.id) {\n      this._registerObject(object);\n    }\n    this._xref.add(object.id, {\n      offset: this._length,\n      obj: object\n    });\n    return this._write(object.toString() + \"\\n\\n\");\n  }\n  _updateOutlinesCount(id) {\n    if (this._outlines[id].data.count < 1) {\n      this._outlines[id].data.count -= 1;\n      this._outlines[id].prop(\"Count\", this._outlines[id].data.count);\n    } else {\n      this._outlines[id].data.count = -1;\n      this._outlines[id].prop(\"Count\", this._outlines[id].data.count);\n    }\n    const nextParent = this._outlines[id].data.parentIndex;\n    if (nextParent !== undefined) {\n      this._updateOutlinesCount(nextParent);\n    }\n  }\n\n  // public API\n\n  async end() {\n    await Fragment.prototype.end.call(this);\n    await this._next();\n    await this._endPage();\n    for (const fn of this._finalize) {\n      await fn();\n    }\n    this._pagesObj.prop(\"MediaBox\", new PDF.Array([0, 0, this.width, this.height]));\n    this._pagesObj.prop(\"Kids\", this._pages);\n    this._pagesObj.prop(\"Count\", this._pages.length);\n    await this._writeObject(this._pagesObj);\n    await this._writeObject(this._colorSpace);\n    for (const alias in this._fonts) {\n      const font = this._fonts[alias];\n      await font.f.write(this, font.o);\n    }\n    for (const alias in this._xobjects) {\n      const xobj = this._xobjects[alias];\n      await xobj.x.write(this, xobj.o);\n    }\n    const catalog = new PDF.Object(\"Catalog\");\n    catalog.prop(\"Pages\", this._pagesObj.toReference());\n    if (this._destinations.length > 0) {\n      const destsObj = new PDF.Object();\n      destsObj.prop(\"Dests\", this._destinations);\n      await this._writeObject(destsObj);\n      catalog.prop(\"Names\", destsObj.toReference());\n    }\n    //Write outlines hierarchy if there are outlines\n    if (this._outlines.length > 0) {\n      for (let i = 0; i < this._outlines.length; i += 1) {\n        await this._writeObject(this._outlines[i]);\n      }\n      catalog.prop(\"Outlines\", this._outlines[0].toReference());\n    }\n    await this._writeObject(catalog);\n\n    // document info\n    this.info.creationDate = formatDate(\n    // Default to now and convert to string\n    this.info.creationDate || new Date());\n    if (!this.info.producer) {\n      // Set default producer if not one provided\n      this.info.producer = `pdfjs v${version} (github.com/rkusa/pdfjs)`;\n    }\n    if (\"modDate\" in this.info) {\n      this.info.modDate = formatDate(this.info.modDate);\n    }\n    const infoObj = new PDF.Object();\n    for (const key in InfoKeys) {\n      if (key in this.info) {\n        infoObj.prop(InfoKeys[key], new PDF.String(this.info[key]));\n      }\n    }\n    this._writeObject(infoObj);\n\n    // to support random access to individual objects, a PDF file\n    // contains a cross-reference table that can be used to locate\n    // and directly access pages and other important objects within the file\n    const startxref = this._length;\n    await this._write(this._xref.toString());\n\n    // trailer\n    const objectsCount = this._nextObjectId - 1;\n    const trailer = new PDF.Trailer(objectsCount + 1, catalog, this.info.id, infoObj);\n    await this._write(trailer.toString() + \"\\n\");\n\n    // startxref\n    await this._write(\"startxref\\n\" + startxref + \"\\n%%EOF\");\n\n    // close readable stream\n    this.push(null);\n  }\n  asBuffer(opts, callback) {\n    if (typeof opts === \"function\") {\n      callback = opts;\n      opts = undefined;\n    }\n    const shouldEnd = !opts || opts.end !== false;\n    let p = new Promise((resolve, reject) => {\n      const chunks = [];\n      this.on(\"data\", chunk => chunks.push(chunk));\n      this.on(\"end\", () => resolve(Buffer.concat(chunks)));\n      this.on(\"error\", reject);\n      if (shouldEnd) {\n        this.end().catch(reject);\n      }\n    });\n    if (typeof callback === \"function\") {\n      p = p.then(data => callback(null, data)).catch(callback);\n    }\n    return p;\n  }\n  header() {\n    const Header = require(\"./header\");\n    const ctx = new Header(this, this);\n    this._begin(ctx);\n    this._pending.push(() => {\n      this._header = ctx;\n      return ctx._start();\n    });\n    return ctx;\n  }\n  footer() {\n    const Footer = require(\"./footer\");\n    const ctx = new Footer(this, this);\n    this._begin(ctx);\n    this._pending.push(() => {\n      this._footer = ctx;\n      return ctx._start();\n    });\n    return ctx;\n  }\n  addPagesOf(external) {\n    if (!(external instanceof ExternalDocument)) {\n      throw new TypeError(\"argument must be of type ExternalDocument\");\n    }\n    this._begin(null);\n    this._pending.push(() => external.write(this));\n  }\n  addPageOf(page, external) {\n    if (!(external instanceof ExternalDocument)) {\n      throw new TypeError(\"argument must be of type ExternalDocument\");\n    }\n    if (!page || page < 1 || page > external.pageCount) {\n      throw new TypeError(\"ExternalDocument does not have page \" + page);\n    }\n    this._begin(null);\n    this._pending.push(() => external.write(this, page));\n  }\n  setTemplate(external, firstPageOnly = false) {\n    if (!(external instanceof ExternalDocument)) {\n      throw new TypeError(\"argument must be of type ExternalDocument\");\n    }\n    this._begin(null);\n    this._pending.push(() => external.setAsTemplate(this, firstPageOnly));\n  }\n  outline(title, destination, parent) {\n    // Skip empty titles and/or destination\n    if (title === undefined || destination === undefined) return;\n\n    // Create the root outline the first time this method is called\n    if (this._outlines.length === 0) {\n      this._outlines[0] = new PDF.Object(\"Outlines\");\n      this._outlines[0].data = {\n        type: \"Outlines\"\n      };\n      this._registerObject(this._outlines[0]);\n    }\n    // Find parent item\n    let parentIndex;\n    if (typeof parent === \"number\" && parent >= 0 && parent <= this._outlines.length) {\n      // the user provided a valid index number: use it as the parentIndex\n      parentIndex = parent;\n    } else {\n      // the user did not provide a valid index number: search for it in the outline array\n      // if it is not found, create the corresponding parent at root level\n      if (parent === undefined || parent === \"\") {\n        parentIndex = 0;\n      } else {\n        parentIndex = this._outlines.findIndex((item, index) => item.data.title === parent);\n        if (parentIndex === -1) parentIndex = this.outline(parent, destination);\n      }\n    }\n\n    // Find siblings\n    let siblingsIndexes = this._outlines.reduce((result, item, index) => {\n      if (index !== 0 && item.data.parentIndex === parentIndex) result.push(index);\n      return result;\n    }, []);\n\n    // Create item\n    const outline = new PDF.Object();\n    outline.data = {\n      title,\n      destination,\n      parent\n    };\n    outline.prop(\"Title\", new PDF.String(title));\n    outline.prop(\"Parent\", this._outlines[parentIndex].toReference());\n    outline.prop(\"A\", new PDF.Dictionary({\n      S: \"GoTo\",\n      D: new PDF.String(destination)\n    }));\n    this._registerObject(outline);\n    const outlineIndex = this._outlines.push(outline) - 1;\n\n    // Chain to siblings\n    const prevSiblingIndex = siblingsIndexes[siblingsIndexes.length - 1];\n    if (prevSiblingIndex > 0) {\n      // Next\n      this._outlines[prevSiblingIndex].data.nextId = outlineIndex;\n      this._outlines[prevSiblingIndex].prop(\"Next\", this._outlines[outlineIndex].toReference());\n      // Prev\n      this._outlines[outlineIndex].data.prevId = prevSiblingIndex;\n      this._outlines[outlineIndex].prop(\"Prev\", this._outlines[prevSiblingIndex].toReference());\n    }\n\n    // Chain to parents\n    this._outlines[outlineIndex].data.parentIndex = parentIndex;\n    if (siblingsIndexes.length === 0) {\n      // First\n      this._outlines[parentIndex].data.firstIndex = outlineIndex;\n      this._outlines[parentIndex].prop(\"First\", this._outlines[outlineIndex].toReference());\n    }\n    // Last\n    this._outlines[parentIndex].data.lastIndex = outlineIndex;\n    this._outlines[parentIndex].prop(\"Last\", this._outlines[outlineIndex].toReference());\n    // Count(s)\n    this._updateOutlinesCount(parentIndex);\n    return outlineIndex;\n  }\n}\nObject.assign(Document.prototype, {\n  _begin: Fragment.prototype._begin,\n  _end: Fragment.prototype._end,\n  _opts: Fragment.prototype._opts,\n  text: Fragment.prototype.text,\n  cell: Fragment.prototype.cell,\n  table: Fragment.prototype.table,\n  image: Fragment.prototype.image,\n  pageBreak: Fragment.prototype.pageBreak,\n  op: Fragment.prototype.op,\n  destination: Fragment.prototype.destination\n});\nclass AliasGenerator {\n  constructor() {\n    this.nextId = {};\n    this.blocked = new Set();\n  }\n  next(prefix) {\n    if (!(prefix in this.nextId)) {\n      this.nextId[prefix] = 1;\n    }\n    let next;\n    do {\n      next = prefix + this.nextId[prefix]++;\n    } while (this.blocked.has(next));\n    return next;\n  }\n  block(alias) {\n    alias = String(alias);\n    if (alias[0] === \"/\") {\n      alias = alias.slice(1);\n    }\n    this.blocked.add(alias);\n  }\n  isBlocked(alias) {\n    alias = String(alias);\n    if (alias[0] === \"/\") {\n      alias = alias.slice(1);\n    }\n    return this.blocked.has(alias);\n  }\n  reset(prefix) {\n    this.nextId[prefix] = 1;\n  }\n}\nconst InfoKeys = {\n  title: \"Title\",\n  author: \"Author\",\n  subject: \"Subject\",\n  keywords: \"Keywords\",\n  creator: \"Creator\",\n  producer: \"Producer\",\n  creationDate: \"CreationDate\",\n  modDate: \"ModDate\"\n};\nfunction formatDate(date) {\n  let str = \"D:\" + date.getFullYear() + (\"00\" + (date.getMonth() + 1)).slice(-2) + (\"00\" + date.getDate()).slice(-2) + (\"00\" + date.getHours()).slice(-2) + (\"00\" + date.getMinutes()).slice(-2) + (\"00\" + date.getSeconds()).slice(-2);\n  let offset = date.getTimezoneOffset();\n  const rel = offset === 0 ? \"Z\" : offset > 0 ? \"-\" : \"+\";\n  offset = Math.abs(offset);\n  const hoursOffset = Math.floor(offset / 60);\n  const minutesOffset = offset - hoursOffset * 60;\n  str += rel + (\"00\" + hoursOffset).slice(-2) + \"'\" + (\"00\" + minutesOffset).slice(-2) + \"'\";\n  return str;\n}\nmodule.exports = Document;","map":{"version":3,"names":["Cursor","require","Fragment","ops","PDF","Readable","v4","uuidv4","util","ContentChunk","ExternalDocument","Font","version","RESOLVE","Promise","resolve","Document","constructor","opts","highWaterMark","info","Object","assign","properties","id","width","height","_nextObjectId","_xref","Xref","_reading","_length","header","_pending","_write","current","defaultFont","font","defaultFontSize","fontSize","defaultColor","color","colorToRgb","defaultLineHeight","lineHeight","isFont","TypeError","_fonts","_xobjects","_pageFonts","_annotations","_aliases","AliasGenerator","_mapping","WeakMap","_currentContent","_contents","_contentObjCreator","_finalize","_header","_footer","_template","padding","paddingTop","defaults","paddingBottom","paddingLeft","paddingRight","_cursor","_pages","Array","_pagesObj","_registerObject","_destinations","NameTree","_outlines","_colorSpace","iccProfile","content","prop","length","Name","_currentColorSpace","_next","prototype","_init","call","parent","next","isArray","shift","then","_read","emit","chunk","push","once","_useFont","alias","has","get","isBlocked","delete","undefined","set","fontObj","f","instance","o","toReference","_fontAlias","_fontInstance","_useXObject","xobj","xobjObjs","i","xobjCount","xobjObj","x","aliases","_startPage","_currentPage","Error","page","taken","colorSpaces","_startContentObject","_objects","obj","Do","_render","reset","y","bottomOffset","_endPage","_endContentObject","fonts","Dictionary","xobjects","add","colorSpace","resources","ColorSpace","ProcSet","XObject","contents","map","c","_object","unshift","apply","dictionary","extGStates","shadings","_writeObject","firstPageOnly","_pageBreak","force","_contentStart","offset","rev","toString","CS","cs","object","Stream","_updateOutlinesCount","data","count","nextParent","parentIndex","end","fn","write","catalog","destsObj","creationDate","formatDate","Date","producer","modDate","infoObj","key","InfoKeys","String","startxref","objectsCount","trailer","Trailer","asBuffer","callback","shouldEnd","p","reject","chunks","on","Buffer","concat","catch","Header","ctx","_begin","_start","footer","Footer","addPagesOf","external","addPageOf","pageCount","setTemplate","setAsTemplate","outline","title","destination","type","findIndex","item","index","siblingsIndexes","reduce","result","S","D","outlineIndex","prevSiblingIndex","nextId","prevId","firstIndex","lastIndex","_end","_opts","text","cell","table","image","pageBreak","op","blocked","Set","prefix","block","slice","author","subject","keywords","creator","date","str","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getTimezoneOffset","rel","Math","abs","hoursOffset","floor","minutesOffset","module","exports"],"sources":["C:/xampp/htdocs/stardust/wp-content/themes/stardust-theme/react-src/node_modules/pdfjs/lib/document.js"],"sourcesContent":["\"use strict\";\n\nconst Cursor = require(\"./cursor\");\nconst Fragment = require(\"./fragment\");\nconst ops = require(\"./ops\");\nconst PDF = require(\"./object\");\nconst Readable = require(\"readable-stream\");\nconst { v4: uuidv4 } = require(\"uuid\");\nconst util = require(\"./util\");\nconst ContentChunk = require(\"./content\");\nconst ExternalDocument = require(\"./external\");\nconst Font = require(\"./font/base\");\nconst version = require(\"../package.json\").version;\n\n// constants\nconst RESOLVE = Promise.resolve();\n\nclass Document extends Readable {\n  constructor(opts) {\n    if (!opts) {\n      opts = {};\n    }\n\n    // readable stream options\n    super({\n      highWaterMark: opts.highWaterMark || 16384, // 16kB\n    });\n\n    this.version = \"1.6\";\n    this.info = Object.assign({}, opts.properties, { id: uuidv4() });\n    this.width = opts.width || 595.296;\n    this.height = opts.height || 841.896;\n\n    this._nextObjectId = 1;\n    this._xref = new PDF.Xref();\n    this._reading = false; // wheater someone is reading data from the underlying Readable\n    this._length = 0; // keeps track of the total document length (in byte)\n\n    // header\n    const header =\n      `%PDF-${this.version}\\n` +\n      // The PDF format mandates that we add at least 4 commented binary characters\n      // (ASCII value >= 128), so that generic tools have a chance to detect\n      // that it's a binary file\n      \"%\\xFF\\xFF\\xFF\\xFF\\n\\n\";\n\n    // a backlog of pending operations\n    this._pending = [() => this._write(header)];\n    // this is the current operation that is executed (operations are executed sequentially)\n    this._pending.current = null;\n\n    // init default styling opts\n    this.defaultFont = opts.font || require(\"../font/Helvetica\");\n    this.defaultFontSize = opts.fontSize || 11;\n    this.defaultColor = (opts.color && util.colorToRgb(opts.color)) || [\n      0, 0, 0,\n    ];\n    this.defaultLineHeight = opts.lineHeight || 1.15;\n\n    if (!Font.isFont(this.defaultFont)) {\n      throw new TypeError(\"opts.font must be set to a valid default font\");\n    }\n\n    // create document and page font dict\n    this._fonts = {};\n    this._xobjects = {};\n    this._pageFonts = {};\n    this._annotations = [];\n\n    // these properties are used to keep track of used Font and Image objects and assign ids to\n    // them in a document-scoped way\n    this._aliases = new AliasGenerator();\n    this._mapping = new WeakMap();\n\n    // a page could consist out of multiple content chunks, which are keept track of using the\n    // following properties\n    this._currentContent = null;\n    this._contents = [];\n    this._contentObjCreator = null;\n\n    // this array can be used to register callbacks that are executed when finalizing the document\n    // e.g. rendering the total page count\n    this._finalize = [];\n\n    this._header = this._footer = this._template = null;\n\n    // init cursor\n    // TODO: test for valid values\n    const padding = opts.padding >= 0 ? opts.padding : 20;\n    this.paddingTop = util.defaults(opts.paddingTop, padding);\n    this.paddingBottom = util.defaults(opts.paddingBottom, padding);\n    this.paddingLeft = util.defaults(opts.paddingLeft, padding);\n    this.paddingRight = util.defaults(opts.paddingRight, padding);\n\n    this._cursor = new Cursor(\n      this.width - this.paddingLeft - this.paddingRight,\n      this.height - this.paddingTop - this.paddingBottom, // width, height\n      this.paddingLeft,\n      this.height - this.paddingTop, // x, y\n    );\n\n    // init pages catalog\n    this._pages = new PDF.Array();\n    this._pagesObj = new PDF.Object(\"Pages\");\n    this._registerObject(this._pagesObj);\n\n    // init destinations name tree\n    this._destinations = new PDF.NameTree();\n\n    // init outlines hierarchy\n    this._outlines = [];\n\n    // init color space\n    this._colorSpace = new PDF.Object();\n    const iccProfile = require(\"./sRGB_IEC61966-2-1_black_scaled\") + \"~>\";\n    this._colorSpace.content = \"stream\\n\" + iccProfile + \"\\nendstream\\n\";\n    this._colorSpace.prop(\"Length\", iccProfile.length);\n    this._colorSpace.prop(\"N\", 3);\n    this._colorSpace.prop(\"Alternate\", \"DeviceRGB\");\n    // this._colorSpace.prop('Filter', new PDF.Array([\n    //   new PDF.Name('ASCII85Decode'), new PDF.Name('FlateDecode')\n    // ]))\n    this._colorSpace.prop(\"Filter\", new PDF.Name(\"ASCII85Decode\"));\n    this._registerObject(this._colorSpace);\n    this._currentColorSpace = \"/CS1\";\n\n    // start to work the _pending queue\n    this._next();\n\n    Fragment.prototype._init.call(this, this, this);\n  }\n\n  /// private API\n\n  _next() {\n    // return if there is already an operation worked on\n    if (this._pending.current) {\n      return this._pending.current;\n    }\n\n    // variables used to traverse the nested queue\n    let parent = this._pending;\n    let next = parent[0];\n\n    // if there is nothing in the queue, we are done here\n    if (!next) {\n      return RESOLVE;\n    }\n\n    // the operation queue is a nested array, e.g.: [op1, [op2, op3, [ op4 ]], op5]\n    // it is therefore necessary traverse the first element until the first non array element\n    // is encountered\n    while (Array.isArray(next)) {\n      // if the first element is an empty array, remove it and start over\n      if (next.length === 0) {\n        parent.shift();\n        return this._next();\n      }\n\n      parent = next;\n      next = next[0];\n    }\n\n    // remove next from the queue\n    parent.shift();\n\n    // TODO: still necessary?\n    // if (!next) {\n    //   return this._next()\n    // }\n\n    // return and set the current operation that is being executed\n    return (this._pending.current = next().then(() => {\n      // once the execution finished, continue in the queue\n      this._pending.current = null;\n      return this._next();\n    }));\n  }\n\n  // This is method is used by Node.js stream.Readable class, which we inherit from.\n  // The method is called, if data is available from the resource, which means that we should\n  // start pushing data into the read queue (using `this.push(dataChunk)`). It should continue\n  // reading from the resoruce and pushing data until `this.push()` return `false`. Only when it\n  // is called again aft it has stopped should it resume pushing additional data onto the\n  // read queue.\n  _read(/* size */) {\n    this._reading = true;\n    this.emit(\"read\");\n  }\n\n  // This method is used to push data onto the read queue. If the Readable stream is currently\n  // not read from, the writing is postponed.\n  _write(chunk) {\n    if (this._reading) {\n      if (!this.push(chunk, \"binary\")) {\n        this._reading = false;\n      }\n      this._length += chunk.length;\n      return RESOLVE;\n    } else {\n      return new Promise((resolve) => {\n        this.once(\"read\", () => {\n          resolve(this._write(chunk));\n        });\n      });\n    }\n  }\n\n  _useFont(font) {\n    let alias;\n    if (this._mapping.has(font)) {\n      alias = this._mapping.get(font);\n      // if the alias exists but is now blocked (e.g. because of having set a new template with\n      // colliding aliases), remove the mapping and unset the alias to force creation of a new one\n      if (this._aliases.isBlocked(alias)) {\n        this._mapping.delete(font);\n        alias = undefined;\n      }\n    }\n\n    if (!alias) {\n      alias = new PDF.Name(this._aliases.next(\"F\"));\n      this._mapping.set(font, alias);\n\n      const fontObj = new PDF.Object(\"Font\");\n      this._fonts[alias] = { f: font.instance(), o: fontObj };\n      this._registerObject(fontObj);\n    }\n\n    if (this._currentContent && !(alias in this._currentContent._fonts)) {\n      this._currentContent._fonts[alias] = this._fonts[alias].o.toReference();\n    }\n\n    return alias;\n  }\n\n  _fontAlias(instance) {\n    return this._useFont(instance.parent);\n  }\n\n  _fontInstance(font) {\n    return this._fonts[this._useFont(font)].f;\n  }\n\n  _useXObject(xobj) {\n    let alias;\n    if (this._mapping.has(xobj)) {\n      alias = this._mapping.get(xobj);\n      // if the alias exists but is now blocked (e.g. because of having set a new template with\n      // colliding aliases), remove the mapping and unset the alias to force creation of a new one\n      if (this._aliases.isBlocked(alias)) {\n        this._mapping.delete(xobj);\n        alias = undefined;\n      }\n    }\n\n    if (!alias) {\n      alias = new PDF.Name(this._aliases.next(\"X\"));\n      this._mapping.set(xobj, alias);\n\n      const xobjObjs = [];\n      for (let i = 0; i < xobj.xobjCount; ++i) {\n        const xobjObj = new PDF.Object(\"XObject\");\n        this._registerObject(xobjObj);\n        xobjObjs.push(xobjObj);\n      }\n      this._xobjects[alias] = { x: xobj, o: xobjObjs };\n    }\n\n    if (this._currentContent && !(alias in this._currentContent._xobjects)) {\n      for (let i = 0; i < this._xobjects[alias].o.length; ++i) {\n        this._currentContent._xobjects[alias + \".\" + i] =\n          this._xobjects[alias].o[i].toReference();\n      }\n    }\n\n    const aliases = [];\n    for (let i = 0; i < this._xobjects[alias].o.length; ++i) {\n      aliases.push(alias + \".\" + i);\n    }\n    return aliases;\n  }\n\n  async _startPage() {\n    if (this._currentPage) {\n      throw new Error(\"There is already a started page\");\n    }\n\n    const page = (this._currentPage = new PDF.Object(\"Page\"));\n    this._pages.push(page.toReference());\n\n    if (this._template) {\n      const taken = {};\n      for (const alias in this._template.colorSpaces) {\n        taken[alias] = null;\n      }\n\n      let i = 1;\n      for (1; \"/CS\" + i in taken; ++i) {}\n      this._currentColorSpace = \"/CS\" + i;\n    } else {\n      this._currentColorSpace = \"/CS1\";\n    }\n\n    await this._startContentObject();\n\n    if (this._header) {\n      let chunk = \"\";\n      for (const i in this._header._objects) {\n        const obj = this._header._objects[i];\n        const alias = new PDF.Name(this._aliases.next(\"H\"));\n        this._currentContent._xobjects[alias] = obj.toReference();\n        chunk += ops.Do(alias);\n      }\n\n      await this._write(chunk);\n      await this._header._render();\n    }\n\n    if (this._footer) {\n      let chunk = \"\";\n      for (const i in this._footer._objects) {\n        const obj = this._footer._objects[i];\n        const alias = new PDF.Name(this._aliases.next(\"F\"));\n        this._currentContent._xobjects[alias] = obj.toReference();\n        chunk += ops.Do(alias);\n      }\n\n      await this._write(chunk);\n      await this._footer._render();\n    }\n\n    this._cursor.reset();\n\n    if (this._header) {\n      this._cursor.y -= this._header.height;\n    }\n\n    if (this._footer) {\n      this._cursor.bottomOffset = this._footer.height;\n    }\n  }\n\n  async _endPage() {\n    if (!this._currentPage) {\n      return;\n    }\n\n    await this._endContentObject();\n\n    const fonts = new PDF.Dictionary({});\n    const xobjects = new PDF.Dictionary({});\n\n    for (const content of this._contents) {\n      for (const alias in content._fonts) {\n        fonts.add(alias, content._fonts[alias]);\n      }\n\n      for (const alias in content._xobjects) {\n        xobjects.add(alias, content._xobjects[alias]);\n      }\n    }\n\n    const page = this._currentPage;\n    page.prop(\"Parent\", this._pagesObj.toReference());\n\n    const colorSpace = new PDF.Dictionary({\n      [this._currentColorSpace]: new PDF.Array([\n        new PDF.Name(\"ICCBased\"),\n        this._colorSpace.toReference(),\n      ]),\n    });\n    const resources = new PDF.Dictionary({\n      ColorSpace: colorSpace,\n      ProcSet: new PDF.Array([\n        new PDF.Name(\"PDF\"),\n        new PDF.Name(\"Text\"),\n        new PDF.Name(\"ImageB\"),\n        new PDF.Name(\"ImageC\"),\n        new PDF.Name(\"ImageI\"),\n      ]),\n      Font: fonts,\n      XObject: xobjects,\n    });\n    page.prop(\"Resources\", resources);\n\n    if (this._annotations.length > 0) {\n      page.prop(\"Annots\", new PDF.Array(this._annotations));\n      this._annotations = [];\n    }\n\n    const contents = this._contents.map((c) => c._object.toReference());\n    page.prop(\"Contents\", new PDF.Array(contents));\n\n    if (this._template) {\n      contents.unshift.apply(contents, this._template.contents);\n\n      for (const alias in this._template.colorSpaces) {\n        colorSpace.dictionary[alias] = this._template.colorSpaces[alias];\n      }\n\n      for (const alias in this._template.fonts) {\n        fonts.dictionary[alias] = this._template.fonts[alias];\n      }\n\n      for (const alias in this._template.xobjects) {\n        xobjects.dictionary[alias] = this._template.xobjects[alias];\n      }\n\n      const extGStates = new PDF.Dictionary({});\n      for (const alias in this._template.extGStates) {\n        extGStates.dictionary[alias] = this._template.extGStates[alias];\n      }\n      if (extGStates.length > 0) {\n        resources.set(\"ExtGState\", extGStates);\n      }\n\n      const shadings = new PDF.Dictionary({});\n      for (const alias in this._template.shadings) {\n        shadings.dictionary[alias] = this._template.shadings[alias];\n      }\n      if (shadings.length > 0) {\n        resources.set(\"Shading\", shadings);\n      }\n    }\n\n    await this._writeObject(page);\n\n    this._currentContent = this._currentPage = null;\n    this._contents.length = 0;\n\n    if (this._template && this._template.firstPageOnly) {\n      this._template = null;\n    }\n  }\n\n  async _pageBreak(/* level */) {\n    if (!this._currentPage) {\n      await this._startPage();\n    }\n\n    await this._cursor.reset();\n\n    await this._endPage();\n    await this._startPage();\n  }\n\n  async _startContentObject(obj, force) {\n    // do not create new content object, if current content object is still empty\n    // 16 = /CS1 CS\n    //      /CS1 cs\n    if (!force && this._length - 16 == this._contentStart) {\n      return this._currentContent;\n    }\n\n    if (this._currentContent) {\n      await this._endContentObject();\n    }\n\n    if (this._contentObjCreator) {\n      obj = this._contentObjCreator();\n    }\n\n    const content = (this._currentContent = new ContentChunk(this, obj));\n    this._contents.push(content);\n\n    this._xref.add(content._object.id, {\n      offset: this._length,\n      obj: content._object,\n    });\n\n    let chunk =\n      content._object.id +\n      \" \" +\n      content._object.rev +\n      \" obj\\n\" +\n      content._object.properties.toString() +\n      \"\\n\" +\n      \"stream\\n\";\n\n    this._contentStart = this._length + chunk.length;\n\n    // set color space\n    chunk += ops.CS(this._currentColorSpace) + ops.cs(this._currentColorSpace);\n    await this._write(chunk);\n\n    return content;\n  }\n\n  async _endContentObject() {\n    if (!this._currentContent) {\n      return;\n    }\n\n    this._currentContent._length.content =\n      this._length - this._contentStart - 1;\n    if (this._currentContent._length.content < 0) {\n      this._currentContent._length.content = 0;\n    }\n\n    const chunk = \"endstream\\nendobj\\n\\n\";\n    await this._write(chunk);\n    await this._writeObject(this._currentContent._length);\n\n    this._currentContent = null;\n  }\n\n  _registerObject(object, force) {\n    if (object instanceof PDF.Stream) {\n      object = object.object;\n    }\n\n    if (!force && object.id) {\n      return;\n    }\n\n    object.id = this._nextObjectId;\n    this._nextObjectId++;\n  }\n\n  _writeObject(object) {\n    if (object instanceof PDF.Stream) {\n      object = object.object;\n    }\n\n    if (!object.id) {\n      this._registerObject(object);\n    }\n\n    this._xref.add(object.id, {\n      offset: this._length,\n      obj: object,\n    });\n    return this._write(object.toString() + \"\\n\\n\");\n  }\n\n  _updateOutlinesCount(id) {\n    if (this._outlines[id].data.count < 1) {\n      this._outlines[id].data.count -= 1;\n      this._outlines[id].prop(\"Count\", this._outlines[id].data.count);\n    } else {\n      this._outlines[id].data.count = -1;\n      this._outlines[id].prop(\"Count\", this._outlines[id].data.count);\n    }\n    const nextParent = this._outlines[id].data.parentIndex;\n    if (nextParent !== undefined) {\n      this._updateOutlinesCount(nextParent);\n    }\n  }\n\n  // public API\n\n  async end() {\n    await Fragment.prototype.end.call(this);\n\n    await this._next();\n    await this._endPage();\n\n    for (const fn of this._finalize) {\n      await fn();\n    }\n\n    this._pagesObj.prop(\n      \"MediaBox\",\n      new PDF.Array([0, 0, this.width, this.height]),\n    );\n    this._pagesObj.prop(\"Kids\", this._pages);\n    this._pagesObj.prop(\"Count\", this._pages.length);\n    await this._writeObject(this._pagesObj);\n    await this._writeObject(this._colorSpace);\n\n    for (const alias in this._fonts) {\n      const font = this._fonts[alias];\n      await font.f.write(this, font.o);\n    }\n\n    for (const alias in this._xobjects) {\n      const xobj = this._xobjects[alias];\n      await xobj.x.write(this, xobj.o);\n    }\n\n    const catalog = new PDF.Object(\"Catalog\");\n    catalog.prop(\"Pages\", this._pagesObj.toReference());\n    if (this._destinations.length > 0) {\n      const destsObj = new PDF.Object();\n      destsObj.prop(\"Dests\", this._destinations);\n      await this._writeObject(destsObj);\n      catalog.prop(\"Names\", destsObj.toReference());\n    }\n    //Write outlines hierarchy if there are outlines\n    if (this._outlines.length > 0) {\n      for (let i = 0; i < this._outlines.length; i += 1) {\n        await this._writeObject(this._outlines[i]);\n      }\n      catalog.prop(\"Outlines\", this._outlines[0].toReference());\n    }\n    await this._writeObject(catalog);\n\n    // document info\n    this.info.creationDate = formatDate(\n      // Default to now and convert to string\n      this.info.creationDate || new Date(),\n    );\n    if (!this.info.producer) {\n      // Set default producer if not one provided\n      this.info.producer = `pdfjs v${version} (github.com/rkusa/pdfjs)`;\n    }\n    if (\"modDate\" in this.info) {\n      this.info.modDate = formatDate(this.info.modDate);\n    }\n\n    const infoObj = new PDF.Object();\n    for (const key in InfoKeys) {\n      if (key in this.info) {\n        infoObj.prop(InfoKeys[key], new PDF.String(this.info[key]));\n      }\n    }\n    this._writeObject(infoObj);\n\n    // to support random access to individual objects, a PDF file\n    // contains a cross-reference table that can be used to locate\n    // and directly access pages and other important objects within the file\n    const startxref = this._length;\n    await this._write(this._xref.toString());\n\n    // trailer\n    const objectsCount = this._nextObjectId - 1;\n    const trailer = new PDF.Trailer(\n      objectsCount + 1,\n      catalog,\n      this.info.id,\n      infoObj,\n    );\n    await this._write(trailer.toString() + \"\\n\");\n\n    // startxref\n    await this._write(\"startxref\\n\" + startxref + \"\\n%%EOF\");\n\n    // close readable stream\n    this.push(null);\n  }\n\n  asBuffer(opts, callback) {\n    if (typeof opts === \"function\") {\n      callback = opts;\n      opts = undefined;\n    }\n\n    const shouldEnd = !opts || opts.end !== false;\n    let p = new Promise((resolve, reject) => {\n      const chunks = [];\n      this.on(\"data\", (chunk) => chunks.push(chunk));\n      this.on(\"end\", () => resolve(Buffer.concat(chunks)));\n      this.on(\"error\", reject);\n      if (shouldEnd) {\n        this.end().catch(reject);\n      }\n    });\n    if (typeof callback === \"function\") {\n      p = p.then((data) => callback(null, data)).catch(callback);\n    }\n    return p;\n  }\n\n  header() {\n    const Header = require(\"./header\");\n    const ctx = new Header(this, this);\n    this._begin(ctx);\n\n    this._pending.push(() => {\n      this._header = ctx;\n      return ctx._start();\n    });\n\n    return ctx;\n  }\n\n  footer() {\n    const Footer = require(\"./footer\");\n    const ctx = new Footer(this, this);\n    this._begin(ctx);\n\n    this._pending.push(() => {\n      this._footer = ctx;\n      return ctx._start();\n    });\n\n    return ctx;\n  }\n\n  addPagesOf(external) {\n    if (!(external instanceof ExternalDocument)) {\n      throw new TypeError(\"argument must be of type ExternalDocument\");\n    }\n\n    this._begin(null);\n    this._pending.push(() => external.write(this));\n  }\n\n  addPageOf(page, external) {\n    if (!(external instanceof ExternalDocument)) {\n      throw new TypeError(\"argument must be of type ExternalDocument\");\n    }\n\n    if (!page || page < 1 || page > external.pageCount) {\n      throw new TypeError(\"ExternalDocument does not have page \" + page);\n    }\n\n    this._begin(null);\n    this._pending.push(() => external.write(this, page));\n  }\n\n  setTemplate(external, firstPageOnly = false) {\n    if (!(external instanceof ExternalDocument)) {\n      throw new TypeError(\"argument must be of type ExternalDocument\");\n    }\n\n    this._begin(null);\n    this._pending.push(() => external.setAsTemplate(this, firstPageOnly));\n  }\n\n  outline(title, destination, parent) {\n    // Skip empty titles and/or destination\n    if (title === undefined || destination === undefined) return;\n\n    // Create the root outline the first time this method is called\n    if (this._outlines.length === 0) {\n      this._outlines[0] = new PDF.Object(\"Outlines\");\n      this._outlines[0].data = { type: \"Outlines\" };\n      this._registerObject(this._outlines[0]);\n    }\n    // Find parent item\n    let parentIndex;\n    if (\n      typeof parent === \"number\" &&\n      parent >= 0 &&\n      parent <= this._outlines.length\n    ) {\n      // the user provided a valid index number: use it as the parentIndex\n      parentIndex = parent;\n    } else {\n      // the user did not provide a valid index number: search for it in the outline array\n      // if it is not found, create the corresponding parent at root level\n      if (parent === undefined || parent === \"\") {\n        parentIndex = 0;\n      } else {\n        parentIndex = this._outlines.findIndex(\n          (item, index) => item.data.title === parent,\n        );\n        if (parentIndex === -1) parentIndex = this.outline(parent, destination);\n      }\n    }\n\n    // Find siblings\n    let siblingsIndexes = this._outlines.reduce((result, item, index) => {\n      if (index !== 0 && item.data.parentIndex === parentIndex)\n        result.push(index);\n      return result;\n    }, []);\n\n    // Create item\n    const outline = new PDF.Object();\n    outline.data = { title, destination, parent };\n    outline.prop(\"Title\", new PDF.String(title));\n    outline.prop(\"Parent\", this._outlines[parentIndex].toReference());\n    outline.prop(\n      \"A\",\n      new PDF.Dictionary({\n        S: \"GoTo\",\n        D: new PDF.String(destination),\n      }),\n    );\n    this._registerObject(outline);\n    const outlineIndex = this._outlines.push(outline) - 1;\n\n    // Chain to siblings\n    const prevSiblingIndex = siblingsIndexes[siblingsIndexes.length - 1];\n    if (prevSiblingIndex > 0) {\n      // Next\n      this._outlines[prevSiblingIndex].data.nextId = outlineIndex;\n      this._outlines[prevSiblingIndex].prop(\n        \"Next\",\n        this._outlines[outlineIndex].toReference(),\n      );\n      // Prev\n      this._outlines[outlineIndex].data.prevId = prevSiblingIndex;\n      this._outlines[outlineIndex].prop(\n        \"Prev\",\n        this._outlines[prevSiblingIndex].toReference(),\n      );\n    }\n\n    // Chain to parents\n    this._outlines[outlineIndex].data.parentIndex = parentIndex;\n    if (siblingsIndexes.length === 0) {\n      // First\n      this._outlines[parentIndex].data.firstIndex = outlineIndex;\n      this._outlines[parentIndex].prop(\n        \"First\",\n        this._outlines[outlineIndex].toReference(),\n      );\n    }\n    // Last\n    this._outlines[parentIndex].data.lastIndex = outlineIndex;\n    this._outlines[parentIndex].prop(\n      \"Last\",\n      this._outlines[outlineIndex].toReference(),\n    );\n    // Count(s)\n    this._updateOutlinesCount(parentIndex);\n\n    return outlineIndex;\n  }\n}\n\nObject.assign(Document.prototype, {\n  _begin: Fragment.prototype._begin,\n  _end: Fragment.prototype._end,\n  _opts: Fragment.prototype._opts,\n\n  text: Fragment.prototype.text,\n  cell: Fragment.prototype.cell,\n  table: Fragment.prototype.table,\n  image: Fragment.prototype.image,\n  pageBreak: Fragment.prototype.pageBreak,\n  op: Fragment.prototype.op,\n  destination: Fragment.prototype.destination,\n});\n\nclass AliasGenerator {\n  constructor() {\n    this.nextId = {};\n    this.blocked = new Set();\n  }\n\n  next(prefix) {\n    if (!(prefix in this.nextId)) {\n      this.nextId[prefix] = 1;\n    }\n\n    let next;\n    do {\n      next = prefix + this.nextId[prefix]++;\n    } while (this.blocked.has(next));\n\n    return next;\n  }\n\n  block(alias) {\n    alias = String(alias);\n    if (alias[0] === \"/\") {\n      alias = alias.slice(1);\n    }\n\n    this.blocked.add(alias);\n  }\n\n  isBlocked(alias) {\n    alias = String(alias);\n    if (alias[0] === \"/\") {\n      alias = alias.slice(1);\n    }\n\n    return this.blocked.has(alias);\n  }\n\n  reset(prefix) {\n    this.nextId[prefix] = 1;\n  }\n}\n\nconst InfoKeys = {\n  title: \"Title\",\n  author: \"Author\",\n  subject: \"Subject\",\n  keywords: \"Keywords\",\n  creator: \"Creator\",\n  producer: \"Producer\",\n  creationDate: \"CreationDate\",\n  modDate: \"ModDate\",\n};\n\nfunction formatDate(date) {\n  let str =\n    \"D:\" +\n    date.getFullYear() +\n    (\"00\" + (date.getMonth() + 1)).slice(-2) +\n    (\"00\" + date.getDate()).slice(-2) +\n    (\"00\" + date.getHours()).slice(-2) +\n    (\"00\" + date.getMinutes()).slice(-2) +\n    (\"00\" + date.getSeconds()).slice(-2);\n\n  let offset = date.getTimezoneOffset();\n  const rel = offset === 0 ? \"Z\" : offset > 0 ? \"-\" : \"+\";\n  offset = Math.abs(offset);\n  const hoursOffset = Math.floor(offset / 60);\n  const minutesOffset = offset - hoursOffset * 60;\n\n  str +=\n    rel +\n    (\"00\" + hoursOffset).slice(-2) +\n    \"'\" +\n    (\"00\" + minutesOffset).slice(-2) +\n    \"'\";\n\n  return str;\n}\n\nmodule.exports = Document;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}