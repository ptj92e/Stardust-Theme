{"ast":null,"code":"\"use strict\";\n\nconst Fragment = require(\"./fragment\");\nconst LineBreaker = require(\"@rkusa/linebreak\");\nconst unorm = require(\"unorm\");\nconst ops = require(\"./ops\");\nconst util = require(\"./util\");\nconst Font = require(\"./font/base\");\nconst PDF = require(\"./object\");\nconst UNDERLINE_FLAG = 1;\nconst STRIKETHROUGH_FLAG = 2;\nconst Text = module.exports = class Text extends Fragment {\n  constructor(doc, parent, opts) {\n    super(doc, parent);\n    this._line = [];\n    this._spaceLeft = 0;\n    this._parts = 0;\n    this._isFirstLine = true;\n    this._isNewLine = true;\n    this._previousFont = null;\n    this._previousFontSize = null;\n    this._previousColor = null;\n    this._previousHeight = 0;\n    this._previousDescent = 0;\n    this.opts = opts;\n    this.defaultFont = opts.font || this._doc.defaultFont;\n    this.defaultFontSize = opts.fontSize || this._doc.defaultFontSize;\n    this.defaultColor = opts.color && util.colorToRgb(opts.color) || this._doc.defaultColor;\n    this.defaultLineHeight = opts.lineHeight || this._doc.defaultLineHeight;\n    this.defaultDecoration = (opts.underline ? UNDERLINE_FLAG : 0) | (opts.strikethrough ? STRIKETHROUGH_FLAG : 0);\n    this.alignment = opts.alignment || opts.textAlign || \"left\";\n    this.link = opts.link;\n    this.destination = opts.destination;\n    this.goTo = opts.goTo;\n  }\n\n  /// private API\n\n  async _start() {\n    if (!this._doc._currentContent) {\n      await this._doc._startPage();\n    }\n    this._spaceLeft = this._cursor.width;\n  }\n  async _end() {\n    // write end text\n    await this._doc._write(ops.ET());\n  }\n  async _render(text, opts) {\n    this._parts--;\n    if (!Font.isFont(opts.font || this.defaultFont)) {\n      throw new TypeError(\"invalid font: \" + font);\n    }\n    const font = this._doc._fontInstance(opts.font || this.defaultFont);\n    const fontSize = opts.fontSize || this.defaultFontSize;\n    const color = opts.color && util.colorToRgb(opts.color) || this.defaultColor;\n    const lineHeight = opts.lineHeight || this.defaultLineHeight;\n    const link = opts.link || this.link;\n    const destination = opts.destination || this.destination;\n    const goTo = opts.goTo || this.goTo;\n    const decoration = this.defaultDecoration | (opts.underline ? UNDERLINE_FLAG : 0) | (opts.strikethrough ? STRIKETHROUGH_FLAG : 0);\n\n    // enforce string\n    text = String(text);\n    text = text.replace(/\\r\\n/g, \"\\n\").replace(/\\u2028|\\u2029/g, \"\"); // <- TODO: does this break things?\n\n    const breaker = new LineBreaker(text);\n    let last = 0,\n      bk;\n    const isLastTextChunk = this._parts === 0 && this._ended;\n    let postponeLinebreak = false;\n    let nextWord = null;\n    while (nextWord !== null || postponeLinebreak || (bk = breaker.nextBreak()) || isLastTextChunk && this._line.length > 0) {\n      let word = null;\n      if (nextWord) {\n        word = nextWord;\n        nextWord = null;\n      }\n      // when there is no break, there is an orphan word that just has to be rendered,\n      // i.e., skip to the line rendering\n      else if (bk) {\n        let until = bk.position;\n        const lastIsSpace = text[bk.position - 1].match(/\\s/);\n        if (lastIsSpace) {\n          until--;\n        }\n\n        // get the string between the last break and this one\n        word = text.slice(last, until);\n\n        // separate words, if has whitespace, is at the end of the text or\n        // ends with a whitespace\n        if (bk.position === text.length || lastIsSpace) {\n          last = bk.position;\n        } else {\n          continue;\n        }\n        word = unorm.nfc(word);\n      }\n      let wordWidth = 0;\n      let offsetWidth = 0;\n      let spaceWidth = 0;\n      if (word) {\n        wordWidth = font.stringWidth(word, fontSize);\n        offsetWidth = wordWidth.width;\n        spaceWidth = font.stringWidth(\" \", fontSize).width;\n\n        // add whitespace length for every word, except the first on in the line\n        // on the first line, during the first word the line array is empty, however, for succeeding\n        // lines the line array already contains the word that did not fit into the previous line\n        if (this._line.length > (this._isNewLine ? 0 : 1)) {\n          offsetWidth += spaceWidth;\n        }\n      }\n\n      // render line if there is a line break, if we hit the last word of the text, if we\n      // have manual page breaks, or if there is not enough space on the line left\n      const isLastWord = (!bk || bk.position === text.length) && isLastTextChunk;\n      const notEnoughSpace = this._spaceLeft < offsetWidth;\n      if (postponeLinebreak || bk && bk.required || isLastWord || notEnoughSpace) {\n        // if word is longer than one line\n        if (this._line.length === 0 && notEnoughSpace) {\n          // split word\n          for (let i = word.length - 1; i >= 0; --i) {\n            const w = font.stringWidth(word.slice(i), fontSize);\n            if (this._spaceLeft >= offsetWidth - w.width) {\n              const subword = word.slice(0, i);\n              this._line.push(new TextChunk({\n                wordWidth: font.stringWidth(subword, fontSize),\n                spaceWidth,\n                word: subword,\n                font,\n                fontSize,\n                color,\n                decoration,\n                link,\n                destination,\n                goTo\n              }));\n              offsetWidth -= w.width;\n              this._spaceLeft -= offsetWidth;\n              nextWord = word.slice(i);\n              word = null;\n              break;\n            }\n          }\n        }\n\n        // if there is enough space, add word to the current line\n        if (!postponeLinebreak && word && this._spaceLeft - offsetWidth >= 0) {\n          this._line.push(new TextChunk({\n            wordWidth,\n            spaceWidth,\n            word,\n            font,\n            fontSize,\n            color,\n            decoration,\n            link,\n            destination,\n            goTo\n          }));\n          this._spaceLeft -= offsetWidth;\n          word = null;\n        }\n\n        // render line\n        let left = this._cursor.x;\n\n        // calc max line height\n        let height = 0;\n        let descent = 0;\n        for (const w of this._line) {\n          const h = w.font.lineHeight(w.fontSize, true);\n          if (h > height) {\n            height = h;\n          }\n          const d = -w.font.descent(w.fontSize);\n          if (d > descent) {\n            descent = d;\n          }\n        }\n        height *= lineHeight;\n        descent *= lineHeight;\n        if (height === 0) {\n          height = this._previousHeight;\n          descent = this._previousDescent;\n        }\n\n        // break page if necessary\n        if (!this._cursor.doesFit(height)) {\n          if (!this._isFirstLine) {\n            await this._doc._write(ops.ET());\n          }\n\n          // execute page break\n          // add remaining text as new text to the queue of pending operations\n          let remainingText = bk ? (word ? word + \" \" : \"\") + text.substring(bk.position) : \"\";\n          if (bk && bk.required) {\n            // if the page break happened due to a line break, we have to make sure to add it back\n            // to the queue as well\n            remainingText += \"\\n\";\n          }\n          this._pending.unshift(() => {\n            this._parts++;\n            return this._render(remainingText, opts);\n          });\n          await this._parent._pageBreak(1);\n          this._isFirstLine = true;\n          this._isNewLine = true;\n          this._previousFont = null;\n          this._previousFontSize = null;\n          this._previousColor = null;\n          break;\n        }\n\n        // shift cursor; since rendering is done above the y coordinate,\n        // we have to update the cursor before rendering the line\n        this._cursor.y -= height; // shift y cursor\n\n        // calculate remaining space\n        const freeSpace = this._spaceLeft;\n\n        // alignment\n        let spacing = 0;\n        switch (this.alignment) {\n          case \"right\":\n            left += freeSpace;\n            break;\n          case \"center\":\n            left += this._cursor.width / 2 - (this._cursor.width - freeSpace) / 2;\n            break;\n          case \"justify\":\n            const isLastLine = isLastWord || bk && bk.required;\n            if (isLastLine && freeSpace / this._cursor.width > 0.2) {\n              break;\n            }\n            if (this._line.length > 1) {\n              spacing = freeSpace / (this._line.length - 1);\n            }\n            break;\n        }\n\n        // render words\n        let chunk = \"\";\n        if (this._isFirstLine) {\n          this._previousHeight = height;\n          chunk += ops.BT() +\n          // set initial pos\n          ops.Tm(1, 0, 0, 1, left, this._cursor.y) +\n          // set leading\n          ops.TL(this._previousHeight);\n        } else {\n          const lh = height + this._previousDescent;\n          if (height > 0 && lh !== this._previousHeight) {\n            this._previousHeight = lh;\n            chunk += ops.TL(lh);\n          }\n          if (left > this._cursor.x) {\n            // set new x and y position\n            chunk += ops.Tm(1, 0, 0, 1, left, this._cursor.y);\n          } else {\n            // move to next line\n            chunk += ops.Tstar();\n          }\n        }\n        if (height > 0) {\n          this._previousDescent = descent;\n        }\n        const out = [];\n        const rangeStyleArgs = [this._doc, left, this._cursor.y, height, spacing];\n        const underlineStyle = new UnderlineRangeStyle(...rangeStyleArgs);\n        const strikethroughStyle = new StrikethroughRangeStyle(...rangeStyleArgs);\n        const linkStyle = new LinkRangeStyle(...rangeStyleArgs);\n        const destinationStyle = new DestinationRangeStyle(...rangeStyleArgs);\n        const goToStyle = new GoToRangeStyle(...rangeStyleArgs);\n        const lastIx = this._line.length - 1;\n        for (let i = 0; i < this._line.length; ++i) {\n          const w = this._line[i];\n          const fontStyleChanged = w.font !== this._previousFont || w.fontSize !== this._previousFontSize;\n          const colorChanged = !util.rgbEqual(w.color, this._previousColor);\n          chunk += underlineStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged);\n          chunk += strikethroughStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged);\n          chunk += linkStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged);\n          chunk += destinationStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged);\n          chunk += goToStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged);\n          if (fontStyleChanged || colorChanged) {\n            if (out.length > 0) {\n              chunk += ops.TJ(out);\n            }\n            if (fontStyleChanged) {\n              this._previousFont = w.font;\n              this._previousFontSize = w.fontSize;\n              const alias = this._doc._fontAlias(w.font);\n\n              // set font and font size\n              chunk += ops.Tf(alias, w.fontSize);\n            }\n\n            // set color if it has changed\n            if (colorChanged) {\n              this._previousColor = w.color;\n              chunk += ops.sc(...w.color);\n            }\n            out.length = 0;\n          }\n          const kerning = w.wordWidth.kerning;\n          if (kerning.length > 0) {\n            let pos = 0;\n            for (let i = 0; i < kerning.length; ++i) {\n              let subword = w.word.substring(pos, kerning[i].pos);\n              out.push(w.font.encode(subword), kerning[i].offset);\n              pos = kerning[i].pos;\n            }\n            out.push(w.font.encode(w.word.substring(pos)));\n          } else {\n            out.push(w.font.encode(w.word));\n          }\n          if (i < this._line.length - 1 && w.spaceWidth > 0) {\n            // if is not last and has spaceWidth set\n            out.push(calcSpaceWidth(spacing, w.font, w.fontSize));\n          }\n        }\n        if (out.length > 0) {\n          chunk += ops.TJ(out);\n        }\n        await this._doc._write(chunk);\n        this._cursor.y -= descent;\n\n        // reset / update variables\n        this._spaceLeft = this._cursor.width;\n        this._line.length = 0; // empty line array\n        this._isFirstLine = false;\n        this._isNewLine = bk && bk.required;\n        postponeLinebreak = bk && bk.required && word !== null && word.length > 0;\n      }\n\n      // consider word for next line\n      if (word) {\n        this._line.push(new TextChunk({\n          wordWidth,\n          spaceWidth,\n          word,\n          font,\n          fontSize,\n          color,\n          decoration,\n          link,\n          destination,\n          goTo\n        }));\n        this._spaceLeft -= offsetWidth;\n      }\n      bk = null;\n    }\n  }\n\n  /// public API\n\n  add(text, opts) {\n    this._begin(null); // trigger error, if text is already ended\n    this._parts++;\n    this._pending.push(() => this._render(text, opts || {}));\n    return this;\n  }\n  append(text, opts) {\n    this._begin(null); // trigger error, if text is already ended\n\n    this._parts++;\n    this._pending.push(() => {\n      if (this._line.length > 0) {\n        const w = this._line[this._line.length - 1];\n        this._spaceLeft += w.spaceWidth;\n        w.spaceWidth = 0; // set space width to zero\n      }\n\n      return this._render(text, opts || {});\n    });\n    return this;\n  }\n  br() {\n    this._begin(null); // trigger error, if text is already ended\n\n    this._parts++;\n    this._pending.push(() => this._render(\"\\n\\n\", {}));\n    return this;\n  }\n};\nfunction calcSpaceWidth(spacing, font, fontSize) {\n  const scaleFactor = 1000 / fontSize;\n  return -(spacing + font.stringWidth(\" \", fontSize)) * scaleFactor;\n}\nclass TextChunk {\n  constructor(values) {\n    this.wordWidth = values.wordWidth;\n    this.spaceWidth = values.spaceWidth;\n    this.word = values.word;\n    this.font = values.font;\n    this.fontSize = values.fontSize;\n    this.color = values.color;\n    this.decoration = values.decoration;\n    this.link = values.link;\n    this.destination = values.destination;\n    this.goTo = values.goTo;\n  }\n}\nclass RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    this.doc = doc;\n    this.from = x;\n    this.width = 0;\n    this.y = y;\n    this.height = height;\n    this.spacing = spacing;\n    this.isActive = false;\n    this.lastSpaceWidth = 0;\n  }\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    const shouldApply = this._active(textChunk);\n    let chunk = \"\";\n    if (shouldApply && !fontStyleChanged && this.isActive) {\n      this.width += this.lastSpaceWidth;\n    }\n    if (this.isActive && (!shouldApply || fontStyleChanged)) {\n      chunk += this._applyStyle(textChunk);\n      this.from += this.width + this.lastSpaceWidth;\n      this.width = 0;\n    }\n    if (!this.isActive || shouldApply || this.isActive && fontStyleChanged) {\n      this._start(textChunk);\n    }\n    this.isActive = shouldApply;\n    this.lastSpaceWidth = this.spacing || textChunk.spaceWidth;\n    if (this.isActive) {\n      this.width += textChunk.wordWidth;\n    } else {\n      this.from += textChunk.wordWidth + this.lastSpaceWidth;\n    }\n    if (this.isActive && isLast) {\n      chunk += this._applyStyle(textChunk);\n    }\n    return chunk;\n  }\n  _active(textChunk) {\n    // abstract\n  }\n  _start(textChunk) {\n    // abstract\n  }\n  _applyStyle(textChunk) {\n    // abstract\n  }\n}\nclass UnderlineRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing);\n    this.underlinePosition = 0;\n    this.underlineThickness = 0;\n    this.color = null;\n  }\n  _active(textChunk) {\n    return textChunk.decoration & UNDERLINE_FLAG;\n  }\n  _start(textChunk) {\n    this.underlinePosition = textChunk.font.underlinePosition(textChunk.fontSize);\n    this.underlineThickness = textChunk.font.underlineThickness(textChunk.fontSize);\n    this.color = textChunk.color;\n  }\n  _applyStyle(textChunk) {\n    const y = this.y + this.underlinePosition;\n    return ops.w(this.underlineThickness) +\n    // line width\n    ops.SC(...this.color) +\n    // stroking color\n    ops.S(this.from, y, \"m\", this.from + this.width, y, \"l\"); // line\n  }\n}\n\nclass StrikethroughRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing);\n    this.ascent = 0;\n    this.lineThickness = 0;\n    this.color = null;\n  }\n  _active(textChunk) {\n    return textChunk.decoration & STRIKETHROUGH_FLAG;\n  }\n  _start(textChunk) {\n    this.ascent = textChunk.font.ascent(textChunk.fontSize);\n    this.lineThickness = textChunk.font.underlineThickness(textChunk.fontSize);\n    this.color = textChunk.color;\n  }\n  _applyStyle(textChunk) {\n    const y = this.y + this.ascent * 0.35;\n    return ops.w(this.lineThickness) +\n    // line width\n    ops.SC(...this.color) +\n    // stroking color\n    ops.S(this.from, y, \"m\", this.from + this.width, y, \"l\"); // line\n  }\n}\n\nclass LinkRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing);\n    this.link = null;\n  }\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    if (this.link && textChunk.link !== this.link) {\n      fontStyleChanged = true;\n    }\n    return RangeStyle.prototype.applyStyle.call(this, textChunk, isLast, fontStyleChanged);\n  }\n  _active(textChunk) {\n    return textChunk.link !== undefined;\n  }\n  _start(textChunk) {\n    this.link = textChunk.link;\n  }\n  _applyStyle(textChunk) {\n    this.doc._annotations.push(new PDF.Dictionary({\n      Type: \"Annot\",\n      Subtype: \"Link\",\n      Rect: new PDF.Array([this.from, this.y, this.from + this.width, this.y + this.height]),\n      Border: new PDF.Array([0, 0, 0]),\n      A: new PDF.Dictionary({\n        Type: \"Action\",\n        S: \"URI\",\n        URI: new PDF.String(this.link)\n      })\n    }));\n    return \"\";\n  }\n}\nclass DestinationRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing);\n    this.destination = null;\n  }\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    if (this.destination && textChunk.destination !== this.destination) {\n      fontStyleChanged = true;\n    }\n    return RangeStyle.prototype.applyStyle.call(this, textChunk, isLast, fontStyleChanged);\n  }\n  _active(textChunk) {\n    return textChunk.destination !== undefined;\n  }\n  _start(textChunk) {\n    this.destination = textChunk.destination;\n  }\n  _applyStyle(textChunk) {\n    this.doc._destinations.set(this.destination, new PDF.Array([this.doc._currentPage.toReference(), new PDF.Name(\"XYZ\"), this.from, this.y, null]));\n    return \"\";\n  }\n}\nclass GoToRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing);\n    this.goTo = null;\n  }\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    if (this.goTo && textChunk.goTo !== this.goTo) {\n      fontStyleChanged = true;\n    }\n    return RangeStyle.prototype.applyStyle.call(this, textChunk, isLast, fontStyleChanged);\n  }\n  _active(textChunk) {\n    return textChunk.goTo !== undefined;\n  }\n  _start(textChunk) {\n    this.goTo = textChunk.goTo;\n  }\n  _applyStyle(textChunk) {\n    this.doc._annotations.push(new PDF.Dictionary({\n      Type: \"Annot\",\n      Subtype: \"Link\",\n      Rect: new PDF.Array([this.from, this.y, this.from + this.width, this.y + this.height]),\n      Border: new PDF.Array([0, 0, 0]),\n      A: new PDF.Dictionary({\n        S: \"GoTo\",\n        D: new PDF.String(this.goTo)\n      })\n    }));\n    return \"\";\n  }\n}\nText.DestinationRangeStyle = DestinationRangeStyle;","map":{"version":3,"names":["Fragment","require","LineBreaker","unorm","ops","util","Font","PDF","UNDERLINE_FLAG","STRIKETHROUGH_FLAG","Text","module","exports","constructor","doc","parent","opts","_line","_spaceLeft","_parts","_isFirstLine","_isNewLine","_previousFont","_previousFontSize","_previousColor","_previousHeight","_previousDescent","defaultFont","font","_doc","defaultFontSize","fontSize","defaultColor","color","colorToRgb","defaultLineHeight","lineHeight","defaultDecoration","underline","strikethrough","alignment","textAlign","link","destination","goTo","_start","_currentContent","_startPage","_cursor","width","_end","_write","ET","_render","text","isFont","TypeError","_fontInstance","decoration","String","replace","breaker","last","bk","isLastTextChunk","_ended","postponeLinebreak","nextWord","nextBreak","length","word","until","position","lastIsSpace","match","slice","nfc","wordWidth","offsetWidth","spaceWidth","stringWidth","isLastWord","notEnoughSpace","required","i","w","subword","push","TextChunk","left","x","height","descent","h","d","doesFit","remainingText","substring","_pending","unshift","_parent","_pageBreak","y","freeSpace","spacing","isLastLine","chunk","BT","Tm","TL","lh","Tstar","out","rangeStyleArgs","underlineStyle","UnderlineRangeStyle","strikethroughStyle","StrikethroughRangeStyle","linkStyle","LinkRangeStyle","destinationStyle","DestinationRangeStyle","goToStyle","GoToRangeStyle","lastIx","fontStyleChanged","colorChanged","rgbEqual","applyStyle","TJ","alias","_fontAlias","Tf","sc","kerning","pos","encode","offset","calcSpaceWidth","add","_begin","append","br","scaleFactor","values","RangeStyle","from","isActive","lastSpaceWidth","textChunk","isLast","shouldApply","_active","_applyStyle","underlinePosition","underlineThickness","SC","S","ascent","lineThickness","prototype","call","undefined","_annotations","Dictionary","Type","Subtype","Rect","Array","Border","A","URI","_destinations","set","_currentPage","toReference","Name","D"],"sources":["C:/xampp/htdocs/stardust/wp-content/themes/stardust-theme/react-src/node_modules/pdfjs/lib/text.js"],"sourcesContent":["\"use strict\";\n\nconst Fragment = require(\"./fragment\");\nconst LineBreaker = require(\"@rkusa/linebreak\");\nconst unorm = require(\"unorm\");\nconst ops = require(\"./ops\");\nconst util = require(\"./util\");\nconst Font = require(\"./font/base\");\nconst PDF = require(\"./object\");\n\nconst UNDERLINE_FLAG = 1;\nconst STRIKETHROUGH_FLAG = 2;\n\nconst Text = (module.exports = class Text extends Fragment {\n  constructor(doc, parent, opts) {\n    super(doc, parent);\n\n    this._line = [];\n    this._spaceLeft = 0;\n    this._parts = 0;\n    this._isFirstLine = true;\n    this._isNewLine = true;\n\n    this._previousFont = null;\n    this._previousFontSize = null;\n    this._previousColor = null;\n\n    this._previousHeight = 0;\n    this._previousDescent = 0;\n\n    this.opts = opts;\n    this.defaultFont = opts.font || this._doc.defaultFont;\n    this.defaultFontSize = opts.fontSize || this._doc.defaultFontSize;\n    this.defaultColor =\n      (opts.color && util.colorToRgb(opts.color)) || this._doc.defaultColor;\n    this.defaultLineHeight = opts.lineHeight || this._doc.defaultLineHeight;\n    this.defaultDecoration =\n      (opts.underline ? UNDERLINE_FLAG : 0) |\n      (opts.strikethrough ? STRIKETHROUGH_FLAG : 0);\n\n    this.alignment = opts.alignment || opts.textAlign || \"left\";\n\n    this.link = opts.link;\n    this.destination = opts.destination;\n    this.goTo = opts.goTo;\n  }\n\n  /// private API\n\n  async _start() {\n    if (!this._doc._currentContent) {\n      await this._doc._startPage();\n    }\n\n    this._spaceLeft = this._cursor.width;\n  }\n\n  async _end() {\n    // write end text\n    await this._doc._write(ops.ET());\n  }\n\n  async _render(text, opts) {\n    this._parts--;\n\n    if (!Font.isFont(opts.font || this.defaultFont)) {\n      throw new TypeError(\"invalid font: \" + font);\n    }\n\n    const font = this._doc._fontInstance(opts.font || this.defaultFont);\n    const fontSize = opts.fontSize || this.defaultFontSize;\n    const color =\n      (opts.color && util.colorToRgb(opts.color)) || this.defaultColor;\n    const lineHeight = opts.lineHeight || this.defaultLineHeight;\n    const link = opts.link || this.link;\n    const destination = opts.destination || this.destination;\n    const goTo = opts.goTo || this.goTo;\n    const decoration =\n      this.defaultDecoration |\n      (opts.underline ? UNDERLINE_FLAG : 0) |\n      (opts.strikethrough ? STRIKETHROUGH_FLAG : 0);\n\n    // enforce string\n    text = String(text);\n    text = text.replace(/\\r\\n/g, \"\\n\").replace(/\\u2028|\\u2029/g, \"\"); // <- TODO: does this break things?\n\n    const breaker = new LineBreaker(text);\n    let last = 0,\n      bk;\n\n    const isLastTextChunk = this._parts === 0 && this._ended;\n    let postponeLinebreak = false;\n    let nextWord = null;\n\n    while (\n      nextWord !== null ||\n      postponeLinebreak ||\n      (bk = breaker.nextBreak()) ||\n      (isLastTextChunk && this._line.length > 0)\n    ) {\n      let word = null;\n\n      if (nextWord) {\n        word = nextWord;\n        nextWord = null;\n      }\n      // when there is no break, there is an orphan word that just has to be rendered,\n      // i.e., skip to the line rendering\n      else if (bk) {\n        let until = bk.position;\n\n        const lastIsSpace = text[bk.position - 1].match(/\\s/);\n        if (lastIsSpace) {\n          until--;\n        }\n\n        // get the string between the last break and this one\n        word = text.slice(last, until);\n\n        // separate words, if has whitespace, is at the end of the text or\n        // ends with a whitespace\n        if (bk.position === text.length || lastIsSpace) {\n          last = bk.position;\n        } else {\n          continue;\n        }\n\n        word = unorm.nfc(word);\n      }\n\n      let wordWidth = 0;\n      let offsetWidth = 0;\n      let spaceWidth = 0;\n\n      if (word) {\n        wordWidth = font.stringWidth(word, fontSize);\n        offsetWidth = wordWidth.width;\n        spaceWidth = font.stringWidth(\" \", fontSize).width;\n\n        // add whitespace length for every word, except the first on in the line\n        // on the first line, during the first word the line array is empty, however, for succeeding\n        // lines the line array already contains the word that did not fit into the previous line\n        if (this._line.length > (this._isNewLine ? 0 : 1)) {\n          offsetWidth += spaceWidth;\n        }\n      }\n\n      // render line if there is a line break, if we hit the last word of the text, if we\n      // have manual page breaks, or if there is not enough space on the line left\n      const isLastWord =\n        (!bk || bk.position === text.length) && isLastTextChunk;\n      const notEnoughSpace = this._spaceLeft < offsetWidth;\n      if (\n        postponeLinebreak ||\n        (bk && bk.required) ||\n        isLastWord ||\n        notEnoughSpace\n      ) {\n        // if word is longer than one line\n        if (this._line.length === 0 && notEnoughSpace) {\n          // split word\n          for (let i = word.length - 1; i >= 0; --i) {\n            const w = font.stringWidth(word.slice(i), fontSize);\n\n            if (this._spaceLeft >= offsetWidth - w.width) {\n              const subword = word.slice(0, i);\n              this._line.push(\n                new TextChunk({\n                  wordWidth: font.stringWidth(subword, fontSize),\n                  spaceWidth,\n                  word: subword,\n                  font,\n                  fontSize,\n                  color,\n                  decoration,\n                  link,\n                  destination,\n                  goTo,\n                }),\n              );\n              offsetWidth -= w.width;\n              this._spaceLeft -= offsetWidth;\n\n              nextWord = word.slice(i);\n              word = null;\n\n              break;\n            }\n          }\n        }\n\n        // if there is enough space, add word to the current line\n        if (!postponeLinebreak && word && this._spaceLeft - offsetWidth >= 0) {\n          this._line.push(\n            new TextChunk({\n              wordWidth,\n              spaceWidth,\n              word,\n              font,\n              fontSize,\n              color,\n              decoration,\n              link,\n              destination,\n              goTo,\n            }),\n          );\n          this._spaceLeft -= offsetWidth;\n          word = null;\n        }\n\n        // render line\n        let left = this._cursor.x;\n\n        // calc max line height\n        let height = 0;\n        let descent = 0;\n\n        for (const w of this._line) {\n          const h = w.font.lineHeight(w.fontSize, true);\n          if (h > height) {\n            height = h;\n          }\n\n          const d = -w.font.descent(w.fontSize);\n          if (d > descent) {\n            descent = d;\n          }\n        }\n\n        height *= lineHeight;\n        descent *= lineHeight;\n\n        if (height === 0) {\n          height = this._previousHeight;\n          descent = this._previousDescent;\n        }\n\n        // break page if necessary\n        if (!this._cursor.doesFit(height)) {\n          if (!this._isFirstLine) {\n            await this._doc._write(ops.ET());\n          }\n\n          // execute page break\n          // add remaining text as new text to the queue of pending operations\n          let remainingText = bk\n            ? (word ? word + \" \" : \"\") + text.substring(bk.position)\n            : \"\";\n          if (bk && bk.required) {\n            // if the page break happened due to a line break, we have to make sure to add it back\n            // to the queue as well\n            remainingText += \"\\n\";\n          }\n\n          this._pending.unshift(() => {\n            this._parts++;\n            return this._render(remainingText, opts);\n          });\n\n          await this._parent._pageBreak(1);\n\n          this._isFirstLine = true;\n          this._isNewLine = true;\n          this._previousFont = null;\n          this._previousFontSize = null;\n          this._previousColor = null;\n\n          break;\n        }\n\n        // shift cursor; since rendering is done above the y coordinate,\n        // we have to update the cursor before rendering the line\n        this._cursor.y -= height; // shift y cursor\n\n        // calculate remaining space\n        const freeSpace = this._spaceLeft;\n\n        // alignment\n        let spacing = 0;\n        switch (this.alignment) {\n          case \"right\":\n            left += freeSpace;\n            break;\n          case \"center\":\n            left +=\n              this._cursor.width / 2 - (this._cursor.width - freeSpace) / 2;\n            break;\n          case \"justify\":\n            const isLastLine = isLastWord || (bk && bk.required);\n            if (isLastLine && freeSpace / this._cursor.width > 0.2) {\n              break;\n            }\n            if (this._line.length > 1) {\n              spacing = freeSpace / (this._line.length - 1);\n            }\n            break;\n        }\n\n        // render words\n        let chunk = \"\";\n\n        if (this._isFirstLine) {\n          this._previousHeight = height;\n          chunk +=\n            ops.BT() +\n            // set initial pos\n            ops.Tm(1, 0, 0, 1, left, this._cursor.y) +\n            // set leading\n            ops.TL(this._previousHeight);\n        } else {\n          const lh = height + this._previousDescent;\n\n          if (height > 0 && lh !== this._previousHeight) {\n            this._previousHeight = lh;\n            chunk += ops.TL(lh);\n          }\n\n          if (left > this._cursor.x) {\n            // set new x and y position\n            chunk += ops.Tm(1, 0, 0, 1, left, this._cursor.y);\n          } else {\n            // move to next line\n            chunk += ops.Tstar();\n          }\n        }\n\n        if (height > 0) {\n          this._previousDescent = descent;\n        }\n\n        const out = [];\n\n        const rangeStyleArgs = [\n          this._doc,\n          left,\n          this._cursor.y,\n          height,\n          spacing,\n        ];\n        const underlineStyle = new UnderlineRangeStyle(...rangeStyleArgs);\n        const strikethroughStyle = new StrikethroughRangeStyle(\n          ...rangeStyleArgs,\n        );\n        const linkStyle = new LinkRangeStyle(...rangeStyleArgs);\n        const destinationStyle = new DestinationRangeStyle(...rangeStyleArgs);\n        const goToStyle = new GoToRangeStyle(...rangeStyleArgs);\n\n        const lastIx = this._line.length - 1;\n        for (let i = 0; i < this._line.length; ++i) {\n          const w = this._line[i];\n\n          const fontStyleChanged =\n            w.font !== this._previousFont ||\n            w.fontSize !== this._previousFontSize;\n          const colorChanged = !util.rgbEqual(w.color, this._previousColor);\n\n          chunk += underlineStyle.applyStyle(\n            w,\n            i === lastIx,\n            fontStyleChanged || colorChanged,\n          );\n          chunk += strikethroughStyle.applyStyle(\n            w,\n            i === lastIx,\n            fontStyleChanged || colorChanged,\n          );\n          chunk += linkStyle.applyStyle(\n            w,\n            i === lastIx,\n            fontStyleChanged || colorChanged,\n          );\n          chunk += destinationStyle.applyStyle(\n            w,\n            i === lastIx,\n            fontStyleChanged || colorChanged,\n          );\n          chunk += goToStyle.applyStyle(\n            w,\n            i === lastIx,\n            fontStyleChanged || colorChanged,\n          );\n\n          if (fontStyleChanged || colorChanged) {\n            if (out.length > 0) {\n              chunk += ops.TJ(out);\n            }\n\n            if (fontStyleChanged) {\n              this._previousFont = w.font;\n              this._previousFontSize = w.fontSize;\n\n              const alias = this._doc._fontAlias(w.font);\n\n              // set font and font size\n              chunk += ops.Tf(alias, w.fontSize);\n            }\n\n            // set color if it has changed\n            if (colorChanged) {\n              this._previousColor = w.color;\n              chunk += ops.sc(...w.color);\n            }\n\n            out.length = 0;\n          }\n\n          const kerning = w.wordWidth.kerning;\n          if (kerning.length > 0) {\n            let pos = 0;\n            for (let i = 0; i < kerning.length; ++i) {\n              let subword = w.word.substring(pos, kerning[i].pos);\n              out.push(w.font.encode(subword), kerning[i].offset);\n              pos = kerning[i].pos;\n            }\n            out.push(w.font.encode(w.word.substring(pos)));\n          } else {\n            out.push(w.font.encode(w.word));\n          }\n\n          if (i < this._line.length - 1 && w.spaceWidth > 0) {\n            // if is not last and has spaceWidth set\n            out.push(calcSpaceWidth(spacing, w.font, w.fontSize));\n          }\n        }\n        if (out.length > 0) {\n          chunk += ops.TJ(out);\n        }\n\n        await this._doc._write(chunk);\n\n        this._cursor.y -= descent;\n\n        // reset / update variables\n        this._spaceLeft = this._cursor.width;\n        this._line.length = 0; // empty line array\n        this._isFirstLine = false;\n        this._isNewLine = bk && bk.required;\n\n        postponeLinebreak =\n          bk && bk.required && word !== null && word.length > 0;\n      }\n\n      // consider word for next line\n      if (word) {\n        this._line.push(\n          new TextChunk({\n            wordWidth,\n            spaceWidth,\n            word,\n            font,\n            fontSize,\n            color,\n            decoration,\n            link,\n            destination,\n            goTo,\n          }),\n        );\n\n        this._spaceLeft -= offsetWidth;\n      }\n\n      bk = null;\n    }\n  }\n\n  /// public API\n\n  add(text, opts) {\n    this._begin(null); // trigger error, if text is already ended\n    this._parts++;\n    this._pending.push(() => this._render(text, opts || {}));\n\n    return this;\n  }\n\n  append(text, opts) {\n    this._begin(null); // trigger error, if text is already ended\n\n    this._parts++;\n    this._pending.push(() => {\n      if (this._line.length > 0) {\n        const w = this._line[this._line.length - 1];\n        this._spaceLeft += w.spaceWidth;\n        w.spaceWidth = 0; // set space width to zero\n      }\n      return this._render(text, opts || {});\n    });\n\n    return this;\n  }\n\n  br() {\n    this._begin(null); // trigger error, if text is already ended\n\n    this._parts++;\n    this._pending.push(() => this._render(\"\\n\\n\", {}));\n\n    return this;\n  }\n});\n\nfunction calcSpaceWidth(spacing, font, fontSize) {\n  const scaleFactor = 1000 / fontSize;\n  return -(spacing + font.stringWidth(\" \", fontSize)) * scaleFactor;\n}\n\nclass TextChunk {\n  constructor(values) {\n    this.wordWidth = values.wordWidth;\n    this.spaceWidth = values.spaceWidth;\n    this.word = values.word;\n    this.font = values.font;\n    this.fontSize = values.fontSize;\n    this.color = values.color;\n    this.decoration = values.decoration;\n    this.link = values.link;\n    this.destination = values.destination;\n    this.goTo = values.goTo;\n  }\n}\n\nclass RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    this.doc = doc;\n    this.from = x;\n    this.width = 0;\n    this.y = y;\n    this.height = height;\n    this.spacing = spacing;\n    this.isActive = false;\n    this.lastSpaceWidth = 0;\n  }\n\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    const shouldApply = this._active(textChunk);\n    let chunk = \"\";\n\n    if (shouldApply && !fontStyleChanged && this.isActive) {\n      this.width += this.lastSpaceWidth;\n    }\n\n    if (this.isActive && (!shouldApply || fontStyleChanged)) {\n      chunk += this._applyStyle(textChunk);\n      this.from += this.width + this.lastSpaceWidth;\n      this.width = 0;\n    }\n\n    if (!this.isActive || shouldApply || (this.isActive && fontStyleChanged)) {\n      this._start(textChunk);\n    }\n\n    this.isActive = shouldApply;\n    this.lastSpaceWidth = this.spacing || textChunk.spaceWidth;\n    if (this.isActive) {\n      this.width += textChunk.wordWidth;\n    } else {\n      this.from += textChunk.wordWidth + this.lastSpaceWidth;\n    }\n\n    if (this.isActive && isLast) {\n      chunk += this._applyStyle(textChunk);\n    }\n\n    return chunk;\n  }\n\n  _active(textChunk) {\n    // abstract\n  }\n\n  _start(textChunk) {\n    // abstract\n  }\n\n  _applyStyle(textChunk) {\n    // abstract\n  }\n}\n\nclass UnderlineRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing);\n    this.underlinePosition = 0;\n    this.underlineThickness = 0;\n    this.color = null;\n  }\n\n  _active(textChunk) {\n    return textChunk.decoration & UNDERLINE_FLAG;\n  }\n\n  _start(textChunk) {\n    this.underlinePosition = textChunk.font.underlinePosition(\n      textChunk.fontSize,\n    );\n    this.underlineThickness = textChunk.font.underlineThickness(\n      textChunk.fontSize,\n    );\n    this.color = textChunk.color;\n  }\n\n  _applyStyle(textChunk) {\n    const y = this.y + this.underlinePosition;\n    return (\n      ops.w(this.underlineThickness) + // line width\n      ops.SC(...this.color) + // stroking color\n      ops.S(this.from, y, \"m\", this.from + this.width, y, \"l\")\n    ); // line\n  }\n}\n\nclass StrikethroughRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing);\n    this.ascent = 0;\n    this.lineThickness = 0;\n    this.color = null;\n  }\n\n  _active(textChunk) {\n    return textChunk.decoration & STRIKETHROUGH_FLAG;\n  }\n\n  _start(textChunk) {\n    this.ascent = textChunk.font.ascent(textChunk.fontSize);\n    this.lineThickness = textChunk.font.underlineThickness(textChunk.fontSize);\n    this.color = textChunk.color;\n  }\n\n  _applyStyle(textChunk) {\n    const y = this.y + this.ascent * 0.35;\n    return (\n      ops.w(this.lineThickness) + // line width\n      ops.SC(...this.color) + // stroking color\n      ops.S(this.from, y, \"m\", this.from + this.width, y, \"l\")\n    ); // line\n  }\n}\n\nclass LinkRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing);\n    this.link = null;\n  }\n\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    if (this.link && textChunk.link !== this.link) {\n      fontStyleChanged = true;\n    }\n    return RangeStyle.prototype.applyStyle.call(\n      this,\n      textChunk,\n      isLast,\n      fontStyleChanged,\n    );\n  }\n\n  _active(textChunk) {\n    return textChunk.link !== undefined;\n  }\n\n  _start(textChunk) {\n    this.link = textChunk.link;\n  }\n\n  _applyStyle(textChunk) {\n    this.doc._annotations.push(\n      new PDF.Dictionary({\n        Type: \"Annot\",\n        Subtype: \"Link\",\n        Rect: new PDF.Array([\n          this.from,\n          this.y,\n          this.from + this.width,\n          this.y + this.height,\n        ]),\n        Border: new PDF.Array([0, 0, 0]),\n        A: new PDF.Dictionary({\n          Type: \"Action\",\n          S: \"URI\",\n          URI: new PDF.String(this.link),\n        }),\n      }),\n    );\n    return \"\";\n  }\n}\n\nclass DestinationRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing);\n    this.destination = null;\n  }\n\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    if (this.destination && textChunk.destination !== this.destination) {\n      fontStyleChanged = true;\n    }\n    return RangeStyle.prototype.applyStyle.call(\n      this,\n      textChunk,\n      isLast,\n      fontStyleChanged,\n    );\n  }\n\n  _active(textChunk) {\n    return textChunk.destination !== undefined;\n  }\n\n  _start(textChunk) {\n    this.destination = textChunk.destination;\n  }\n\n  _applyStyle(textChunk) {\n    this.doc._destinations.set(\n      this.destination,\n      new PDF.Array([\n        this.doc._currentPage.toReference(),\n        new PDF.Name(\"XYZ\"),\n        this.from,\n        this.y,\n        null,\n      ]),\n    );\n    return \"\";\n  }\n}\n\nclass GoToRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing);\n    this.goTo = null;\n  }\n\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    if (this.goTo && textChunk.goTo !== this.goTo) {\n      fontStyleChanged = true;\n    }\n    return RangeStyle.prototype.applyStyle.call(\n      this,\n      textChunk,\n      isLast,\n      fontStyleChanged,\n    );\n  }\n\n  _active(textChunk) {\n    return textChunk.goTo !== undefined;\n  }\n\n  _start(textChunk) {\n    this.goTo = textChunk.goTo;\n  }\n\n  _applyStyle(textChunk) {\n    this.doc._annotations.push(\n      new PDF.Dictionary({\n        Type: \"Annot\",\n        Subtype: \"Link\",\n        Rect: new PDF.Array([\n          this.from,\n          this.y,\n          this.from + this.width,\n          this.y + this.height,\n        ]),\n        Border: new PDF.Array([0, 0, 0]),\n        A: new PDF.Dictionary({\n          S: \"GoTo\",\n          D: new PDF.String(this.goTo),\n        }),\n      }),\n    );\n    return \"\";\n  }\n}\n\nText.DestinationRangeStyle = DestinationRangeStyle;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}