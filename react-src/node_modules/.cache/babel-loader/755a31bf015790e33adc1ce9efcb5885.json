{"ast":null,"code":"\"use strict\";\n\nconst Fragment = require(\"./fragment\");\nconst util = require(\"./util\");\nconst ops = require(\"./ops\");\nconst PDF = require(\"./object\");\nmodule.exports = class Table {\n  constructor(doc, parent, opts) {\n    Fragment.prototype._init.call(this, doc, parent);\n    this._cursor = this._cursor.clone();\n    if (\"width\" in opts) {\n      this._cursor.width = opts.width;\n    }\n    this._rowCount = 0;\n    this.widths = [];\n    applyOpts.call(this, opts);\n    if (this.borderVerticalWidths) {\n      this._cursor.width -= this.borderVerticalWidths[0] / 2;\n      this._cursor.startX += this.borderVerticalWidths[0] / 2;\n      this._cursor.width -= this.borderVerticalWidths[this.borderVerticalWidths.length - 1] / 2;\n    }\n\n    // distribute remaining width among *-columns\n    let remainingWidth = this._cursor.width;\n    const distribute = [];\n    for (const i in this.widths) {\n      const w = this.widths[i];\n      if (!w || w === \"*\") {\n        distribute.push(i);\n      } else {\n        remainingWidth -= w;\n      }\n    }\n    if (distribute.length > 0) {\n      const w = remainingWidth / distribute.length;\n      for (const i of distribute) {\n        this.widths[i] = w;\n      }\n    }\n    this._headers = [];\n    // reference to the last header context\n    //  only defined for tables with exclusively headers\n    this._last_header_cxt = null;\n    this._is_header_rendered = false;\n  }\n\n  /// private API\n\n  async _pageBreak(level, insideBreak) {\n    await Fragment.prototype._pageBreak.call(this, level);\n    if (!insideBreak) {\n      await this._renderHeader(true);\n    }\n  }\n  async _end() {\n    // render headers if there are no rows\n    if (!this._is_header_rendered && this._headers.length) {\n      this._pending.push(() => this._renderHeader());\n    }\n    await Fragment.prototype._end.call(this);\n  }\n  _begin(ctx) {\n    Fragment.prototype._begin.call(this, ctx);\n  }\n  async _renderHeader(isPageBreak) {\n    if (!this._headers.length) {\n      return;\n    }\n    if (!this._doc._currentContent) {\n      await this._doc._startPage();\n    }\n    const headerHeight = this._headers.reduce((total, header) => total + header.height, 0);\n    if (!isPageBreak && !this._cursor.doesFit(headerHeight)) {\n      await this._pageBreak(1, false);\n      return;\n    }\n    let chunk = \"\";\n    for (const header of this._headers) {\n      const offset = this._cursor.y - header.startedAtY;\n      if (offset !== 0) {\n        // offset header to the top\n        chunk += ops.q() + ops.cm(1, 0, 0, 1, 0, offset);\n      }\n      for (const obj of header._objects) {\n        const alias = new PDF.Name(\"TH\" + obj.id);\n        this._doc._currentContent._xobjects[alias] = obj.toReference();\n        chunk += ops.Do(alias);\n      }\n      this._cursor.y -= header.height;\n      if (offset !== 0) {\n        chunk += ops.Q();\n      }\n    }\n    await this._doc._write(chunk);\n    this._is_header_rendered = true;\n  }\n  _row(opts, isHeader) {\n    if (!opts || typeof opts !== \"object\") {\n      opts = {};\n    }\n    opts = Object.assign({\n      font: this._doc.defaultFont,\n      fontSize: this._doc.defaultFontSize,\n      color: this._doc.defaultColor,\n      lineHeight: this._doc.defaultLineHeight\n    }, this.opts, opts);\n\n    // whitelist\n    opts = {\n      padding: opts.padding,\n      paddingLeft: opts.paddingLeft,\n      paddingRight: opts.paddingRight,\n      paddingTop: opts.paddingTop,\n      paddingBottom: opts.paddingBottom,\n      backgroundColor: opts.backgroundColor,\n      font: opts.font,\n      fontSize: opts.fontSize,\n      color: opts.color,\n      lineHeight: opts.lineHeight,\n      minHeight: opts.minHeight\n    };\n    const Row = isHeader ? require(\"./tableheader\") : require(\"./row\");\n    const ctx = new Row(this._doc, this, opts);\n    this._last_header_cxt = isHeader ? ctx : null;\n    this._begin(ctx);\n    ctx._widths = this.widths.slice();\n    ctx._borderVerticalWidths = this.borderVerticalWidths && this.borderVerticalWidths.slice();\n    ctx._borderVerticalColors = this.borderVerticalColors && this.borderVerticalColors.slice();\n    if (this.borderHorizontalWidths) {\n      ctx._topBorderWidth = this.borderHorizontalWidths(this._rowCount);\n      ctx._topBorderColor = util.colorToRgb(this.borderHorizontalColors(this._rowCount));\n      if (!isHeader) {\n        ctx._bottomBorderWidth = this.borderHorizontalWidths(this._rowCount + 1);\n        ctx._bottomBorderColor = util.colorToRgb(this.borderHorizontalColors(this._rowCount + 1));\n      }\n\n      // should have a top border if there are only header rows in the table\n      ctx._hasTopBorder = this._rowCount === this._headers.length;\n    }\n    ctx._pending.push(() => ctx._start());\n    this._pending.push(ctx._pending);\n    this._rowCount++;\n    return ctx;\n  }\n\n  /// public API\n\n  end() {\n    // if the table only has headers, add a bottom border to the last header row\n    if (!this._is_header_rendered && this._last_header_cxt && this.borderHorizontalWidths) {\n      this._last_header_cxt._bottomBorderWidth = this.borderHorizontalWidths(this._rowCount);\n      this._last_header_cxt._bottomBorderColor = util.colorToRgb(this.borderHorizontalColors(this._rowCount));\n    }\n    return Fragment.prototype.end.call(this);\n  }\n  row(opts) {\n    // Defer rendering of the headers until either a row is added or _end\n    if (this._rowCount === this._headers.length) {\n      this._pending.push(() => this._renderHeader());\n    }\n    return this._row(opts, false);\n  }\n  header(opts) {\n    // Can only add more headers if there are no rows added yet\n    if (this._rowCount > this._headers.length) {\n      throw new Error(\"The table already has rows, cannot add additional headers\");\n    }\n    const ctx = this._row(opts, true);\n    this._headers.push(ctx);\n    return ctx;\n  }\n};\nfunction applyOpts(opts) {\n  this.opts = opts;\n\n  // opts.width\n  if (\"widths\" in opts && Array.isArray(opts.widths)) {\n    this.widths = opts.widths;\n  } else {\n    throw new TypeError(\"widths (array) option is required for tables\");\n  }\n\n  // opts.borderVerticalWidths\n  this.borderVerticalWidths = null;\n  if (opts.borderVerticalWidths) {\n    if (!Array.isArray(opts.borderVerticalWidths)) {\n      throw new TypeError(\"borderVerticalWidths must be an array\");\n    }\n    if (opts.borderVerticalWidths.length !== this.widths.length + 1) {\n      throw new TypeError(`wrong borderVerticalWidths length (expected ${this.widths.length + 1}; got ${opts.borderVerticalWidths.length})`);\n    }\n    this.borderVerticalWidths = opts.borderVerticalWidths;\n  }\n  // opts.borderVerticalWidth\n  else if (typeof opts.borderVerticalWidth === \"number\") {\n    this.borderVerticalWidths = [];\n    for (let i = 0; i <= this.widths.length; ++i) {\n      this.borderVerticalWidths.push(opts.borderVerticalWidth);\n    }\n  }\n\n  // opts.borderVerticalColors\n  this.borderVerticalColors = null;\n  if (opts.borderVerticalColors) {\n    if (!Array.isArray(opts.borderVerticalColors)) {\n      throw new TypeError(\"borderVerticalColors must be an array\");\n    }\n    if (opts.borderVerticalColors.length !== this.widths.length + 1) {\n      throw new TypeError(`wrong borderVerticalColors length (expected ${this.widths.length + 1}; got ${opts.borderVerticalColors.length})`);\n    }\n    this.borderVerticalColors = opts.borderVerticalColors.map(c => util.colorToRgb(c));\n  }\n  // opts.borderVerticalColor\n  else if (typeof opts.borderVerticalColor === \"number\") {\n    this.borderVerticalColors = [];\n    const color = util.colorToRgb(opts.borderVerticalColor);\n    for (let i = 0; i <= this.widths.length; ++i) {\n      this.borderVerticalColors.push(color);\n    }\n  }\n\n  // opts.borderHorizontalWidths\n  this.borderHorizontalWidths = null;\n  if (opts.borderHorizontalWidths) {\n    if (typeof opts.borderHorizontalWidths !== \"function\") {\n      throw new TypeError(\"borderHorizontalWidths must be a function\");\n    }\n    this.borderHorizontalWidths = opts.borderHorizontalWidths;\n  }\n  // opts.borderHorizontalWidth\n  else if (typeof opts.borderHorizontalWidth === \"number\") {\n    this.borderHorizontalWidths = () => opts.borderHorizontalWidth;\n  }\n\n  // opts.borderHorizontalColors\n  this.borderHorizontalColors = null;\n  if (opts.borderHorizontalColors) {\n    if (typeof opts.borderHorizontalColors !== \"function\") {\n      throw new TypeError(\"borderHorizontalColors must be a function\");\n    }\n    this.borderHorizontalColors = opts.borderHorizontalColors;\n  }\n  // opts.borderHorizontalColor\n  else if (typeof opts.borderHorizontalColor === \"number\") {\n    this.borderHorizontalColors = () => opts.borderHorizontalColor;\n  }\n\n  // opts.borderWidth\n  const borderWidth = opts.borderWidth || 0;\n  if (borderWidth > 0) {\n    if (!this.borderVerticalWidths) {\n      this.borderVerticalWidths = [];\n      for (let i = 0; i <= this.widths.length; ++i) {\n        this.borderVerticalWidths.push(borderWidth);\n      }\n    }\n    if (!this.borderHorizontalWidths) {\n      this.borderHorizontalWidths = () => borderWidth;\n    }\n  }\n\n  // opts.borderColor\n  const borderColor = opts.borderColor || 0x000000;\n  if (!this.borderVerticalColors) {\n    this.borderVerticalColors = [];\n    for (let i = 0; i <= this.widths.length; ++i) {\n      this.borderVerticalColors.push(util.colorToRgb(borderColor));\n    }\n  }\n  if (!this.borderHorizontalColors) {\n    this.borderHorizontalColors = () => borderColor;\n  }\n}","map":{"version":3,"names":["Fragment","require","util","ops","PDF","module","exports","Table","constructor","doc","parent","opts","prototype","_init","call","_cursor","clone","width","_rowCount","widths","applyOpts","borderVerticalWidths","startX","length","remainingWidth","distribute","i","w","push","_headers","_last_header_cxt","_is_header_rendered","_pageBreak","level","insideBreak","_renderHeader","_end","_pending","_begin","ctx","isPageBreak","_doc","_currentContent","_startPage","headerHeight","reduce","total","header","height","doesFit","chunk","offset","y","startedAtY","q","cm","obj","_objects","alias","Name","id","_xobjects","toReference","Do","Q","_write","_row","isHeader","Object","assign","font","defaultFont","fontSize","defaultFontSize","color","defaultColor","lineHeight","defaultLineHeight","padding","paddingLeft","paddingRight","paddingTop","paddingBottom","backgroundColor","minHeight","Row","_widths","slice","_borderVerticalWidths","_borderVerticalColors","borderVerticalColors","borderHorizontalWidths","_topBorderWidth","_topBorderColor","colorToRgb","borderHorizontalColors","_bottomBorderWidth","_bottomBorderColor","_hasTopBorder","_start","end","row","Error","Array","isArray","TypeError","borderVerticalWidth","map","c","borderVerticalColor","borderHorizontalWidth","borderHorizontalColor","borderWidth","borderColor"],"sources":["C:/xampp/htdocs/stardust/wp-content/themes/stardust-theme/react-src/node_modules/pdfjs/lib/table.js"],"sourcesContent":["\"use strict\";\n\nconst Fragment = require(\"./fragment\");\nconst util = require(\"./util\");\nconst ops = require(\"./ops\");\nconst PDF = require(\"./object\");\n\nmodule.exports = class Table {\n  constructor(doc, parent, opts) {\n    Fragment.prototype._init.call(this, doc, parent);\n\n    this._cursor = this._cursor.clone();\n    if (\"width\" in opts) {\n      this._cursor.width = opts.width;\n    }\n\n    this._rowCount = 0;\n    this.widths = [];\n\n    applyOpts.call(this, opts);\n\n    if (this.borderVerticalWidths) {\n      this._cursor.width -= this.borderVerticalWidths[0] / 2;\n      this._cursor.startX += this.borderVerticalWidths[0] / 2;\n      this._cursor.width -=\n        this.borderVerticalWidths[this.borderVerticalWidths.length - 1] / 2;\n    }\n\n    // distribute remaining width among *-columns\n    let remainingWidth = this._cursor.width;\n    const distribute = [];\n\n    for (const i in this.widths) {\n      const w = this.widths[i];\n      if (!w || w === \"*\") {\n        distribute.push(i);\n      } else {\n        remainingWidth -= w;\n      }\n    }\n\n    if (distribute.length > 0) {\n      const w = remainingWidth / distribute.length;\n\n      for (const i of distribute) {\n        this.widths[i] = w;\n      }\n    }\n\n    this._headers = [];\n    // reference to the last header context\n    //  only defined for tables with exclusively headers\n    this._last_header_cxt = null;\n    this._is_header_rendered = false;\n  }\n\n  /// private API\n\n  async _pageBreak(level, insideBreak) {\n    await Fragment.prototype._pageBreak.call(this, level);\n\n    if (!insideBreak) {\n      await this._renderHeader(true);\n    }\n  }\n\n  async _end() {\n    // render headers if there are no rows\n    if (!this._is_header_rendered && this._headers.length) {\n      this._pending.push(() => this._renderHeader());\n    }\n    await Fragment.prototype._end.call(this);\n  }\n\n  _begin(ctx) {\n    Fragment.prototype._begin.call(this, ctx);\n  }\n\n  async _renderHeader(isPageBreak) {\n    if (!this._headers.length) {\n      return;\n    }\n\n    if (!this._doc._currentContent) {\n      await this._doc._startPage();\n    }\n\n    const headerHeight = this._headers.reduce(\n      (total, header) => total + header.height,\n      0,\n    );\n\n    if (!isPageBreak && !this._cursor.doesFit(headerHeight)) {\n      await this._pageBreak(1, false);\n      return;\n    }\n\n    let chunk = \"\";\n\n    for (const header of this._headers) {\n      const offset = this._cursor.y - header.startedAtY;\n      if (offset !== 0) {\n        // offset header to the top\n        chunk += ops.q() + ops.cm(1, 0, 0, 1, 0, offset);\n      }\n\n      for (const obj of header._objects) {\n        const alias = new PDF.Name(\"TH\" + obj.id);\n        this._doc._currentContent._xobjects[alias] = obj.toReference();\n        chunk += ops.Do(alias);\n      }\n\n      this._cursor.y -= header.height;\n\n      if (offset !== 0) {\n        chunk += ops.Q();\n      }\n    }\n\n    await this._doc._write(chunk);\n    this._is_header_rendered = true;\n  }\n\n  _row(opts, isHeader) {\n    if (!opts || typeof opts !== \"object\") {\n      opts = {};\n    }\n\n    opts = Object.assign(\n      {\n        font: this._doc.defaultFont,\n        fontSize: this._doc.defaultFontSize,\n        color: this._doc.defaultColor,\n        lineHeight: this._doc.defaultLineHeight,\n      },\n      this.opts,\n      opts,\n    );\n\n    // whitelist\n    opts = {\n      padding: opts.padding,\n      paddingLeft: opts.paddingLeft,\n      paddingRight: opts.paddingRight,\n      paddingTop: opts.paddingTop,\n      paddingBottom: opts.paddingBottom,\n      backgroundColor: opts.backgroundColor,\n      font: opts.font,\n      fontSize: opts.fontSize,\n      color: opts.color,\n      lineHeight: opts.lineHeight,\n      minHeight: opts.minHeight,\n    };\n\n    const Row = isHeader ? require(\"./tableheader\") : require(\"./row\");\n    const ctx = new Row(this._doc, this, opts);\n    this._last_header_cxt = isHeader ? ctx : null;\n    this._begin(ctx);\n\n    ctx._widths = this.widths.slice();\n    ctx._borderVerticalWidths =\n      this.borderVerticalWidths && this.borderVerticalWidths.slice();\n    ctx._borderVerticalColors =\n      this.borderVerticalColors && this.borderVerticalColors.slice();\n\n    if (this.borderHorizontalWidths) {\n      ctx._topBorderWidth = this.borderHorizontalWidths(this._rowCount);\n      ctx._topBorderColor = util.colorToRgb(\n        this.borderHorizontalColors(this._rowCount),\n      );\n\n      if (!isHeader) {\n        ctx._bottomBorderWidth = this.borderHorizontalWidths(\n          this._rowCount + 1,\n        );\n        ctx._bottomBorderColor = util.colorToRgb(\n          this.borderHorizontalColors(this._rowCount + 1),\n        );\n      }\n\n      // should have a top border if there are only header rows in the table\n      ctx._hasTopBorder = this._rowCount === this._headers.length;\n    }\n\n    ctx._pending.push(() => ctx._start());\n    this._pending.push(ctx._pending);\n\n    this._rowCount++;\n\n    return ctx;\n  }\n\n  /// public API\n\n  end() {\n    // if the table only has headers, add a bottom border to the last header row\n    if (\n      !this._is_header_rendered &&\n      this._last_header_cxt &&\n      this.borderHorizontalWidths\n    ) {\n      this._last_header_cxt._bottomBorderWidth = this.borderHorizontalWidths(\n        this._rowCount,\n      );\n      this._last_header_cxt._bottomBorderColor = util.colorToRgb(\n        this.borderHorizontalColors(this._rowCount),\n      );\n    }\n    return Fragment.prototype.end.call(this);\n  }\n\n  row(opts) {\n    // Defer rendering of the headers until either a row is added or _end\n    if (this._rowCount === this._headers.length) {\n      this._pending.push(() => this._renderHeader());\n    }\n    return this._row(opts, false);\n  }\n\n  header(opts) {\n    // Can only add more headers if there are no rows added yet\n    if (this._rowCount > this._headers.length) {\n      throw new Error(\n        \"The table already has rows, cannot add additional headers\",\n      );\n    }\n    const ctx = this._row(opts, true);\n    this._headers.push(ctx);\n    return ctx;\n  }\n};\n\nfunction applyOpts(opts) {\n  this.opts = opts;\n\n  // opts.width\n  if (\"widths\" in opts && Array.isArray(opts.widths)) {\n    this.widths = opts.widths;\n  } else {\n    throw new TypeError(\"widths (array) option is required for tables\");\n  }\n\n  // opts.borderVerticalWidths\n  this.borderVerticalWidths = null;\n  if (opts.borderVerticalWidths) {\n    if (!Array.isArray(opts.borderVerticalWidths)) {\n      throw new TypeError(\"borderVerticalWidths must be an array\");\n    }\n\n    if (opts.borderVerticalWidths.length !== this.widths.length + 1) {\n      throw new TypeError(\n        `wrong borderVerticalWidths length (expected ${\n          this.widths.length + 1\n        }; got ${opts.borderVerticalWidths.length})`,\n      );\n    }\n\n    this.borderVerticalWidths = opts.borderVerticalWidths;\n  }\n  // opts.borderVerticalWidth\n  else if (typeof opts.borderVerticalWidth === \"number\") {\n    this.borderVerticalWidths = [];\n    for (let i = 0; i <= this.widths.length; ++i) {\n      this.borderVerticalWidths.push(opts.borderVerticalWidth);\n    }\n  }\n\n  // opts.borderVerticalColors\n  this.borderVerticalColors = null;\n  if (opts.borderVerticalColors) {\n    if (!Array.isArray(opts.borderVerticalColors)) {\n      throw new TypeError(\"borderVerticalColors must be an array\");\n    }\n\n    if (opts.borderVerticalColors.length !== this.widths.length + 1) {\n      throw new TypeError(\n        `wrong borderVerticalColors length (expected ${\n          this.widths.length + 1\n        }; got ${opts.borderVerticalColors.length})`,\n      );\n    }\n\n    this.borderVerticalColors = opts.borderVerticalColors.map((c) =>\n      util.colorToRgb(c),\n    );\n  }\n  // opts.borderVerticalColor\n  else if (typeof opts.borderVerticalColor === \"number\") {\n    this.borderVerticalColors = [];\n    const color = util.colorToRgb(opts.borderVerticalColor);\n    for (let i = 0; i <= this.widths.length; ++i) {\n      this.borderVerticalColors.push(color);\n    }\n  }\n\n  // opts.borderHorizontalWidths\n  this.borderHorizontalWidths = null;\n  if (opts.borderHorizontalWidths) {\n    if (typeof opts.borderHorizontalWidths !== \"function\") {\n      throw new TypeError(\"borderHorizontalWidths must be a function\");\n    }\n\n    this.borderHorizontalWidths = opts.borderHorizontalWidths;\n  }\n  // opts.borderHorizontalWidth\n  else if (typeof opts.borderHorizontalWidth === \"number\") {\n    this.borderHorizontalWidths = () => opts.borderHorizontalWidth;\n  }\n\n  // opts.borderHorizontalColors\n  this.borderHorizontalColors = null;\n  if (opts.borderHorizontalColors) {\n    if (typeof opts.borderHorizontalColors !== \"function\") {\n      throw new TypeError(\"borderHorizontalColors must be a function\");\n    }\n\n    this.borderHorizontalColors = opts.borderHorizontalColors;\n  }\n  // opts.borderHorizontalColor\n  else if (typeof opts.borderHorizontalColor === \"number\") {\n    this.borderHorizontalColors = () => opts.borderHorizontalColor;\n  }\n\n  // opts.borderWidth\n  const borderWidth = opts.borderWidth || 0;\n  if (borderWidth > 0) {\n    if (!this.borderVerticalWidths) {\n      this.borderVerticalWidths = [];\n      for (let i = 0; i <= this.widths.length; ++i) {\n        this.borderVerticalWidths.push(borderWidth);\n      }\n    }\n\n    if (!this.borderHorizontalWidths) {\n      this.borderHorizontalWidths = () => borderWidth;\n    }\n  }\n\n  // opts.borderColor\n  const borderColor = opts.borderColor || 0x000000;\n  if (!this.borderVerticalColors) {\n    this.borderVerticalColors = [];\n    for (let i = 0; i <= this.widths.length; ++i) {\n      this.borderVerticalColors.push(util.colorToRgb(borderColor));\n    }\n  }\n\n  if (!this.borderHorizontalColors) {\n    this.borderHorizontalColors = () => borderColor;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}