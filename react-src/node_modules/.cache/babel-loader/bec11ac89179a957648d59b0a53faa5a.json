{"ast":null,"code":"\"use strict\";\n\nconst Fragment = require(\"./fragment\");\nconst util = require(\"./util\");\nconst ops = require(\"./ops\");\nconst Cell = require(\"./cell\");\nmodule.exports = class Row {\n  constructor(doc, parent, opts) {\n    Fragment.prototype._init.call(this, doc, parent);\n    this.opts = opts;\n\n    // use an own queue for pending operations\n    this._pending = [];\n\n    // keep track of the cells that have already been ended;\n    // this is necessary to be able to still draw their background and finalize their rendering\n    // once all cells are ended (scenario where not all cells span the same amount of pages)\n    this._endedCells = [];\n\n    // keep a count of not ended cells to adjust the rotation of cells on page breaks properly\n    this._columns = 0;\n\n    // when a page break occures inside a cell, the cells are rotated before an actual page\n    // break is rendered; i.e., all cells of the row are rendered horizontally\n    this._rotated = 0;\n\n    // this is used to keep track of the starting y of the row to reset the cursor's y to\n    // this value for each cell (since they are horizontally aligned)\n    this._y = 0;\n\n    // on each page the row is rendered on, the row keeps track of the maximal y (or minimum\n    // in terms of PDF, because y 0 is on the bottom) a cell is rendered to, to be able to align\n    // the backgrounds of all cells to the same height\n    this._endY = null;\n    this._widths = [];\n    this._topBorderWidth = 0;\n    this._topBorderColor = 0x000000;\n    this._bottomBorderWidth = 0;\n    this._bottomBorderColor = 0x000000;\n    this._borderVerticalWidths = [];\n    this._borderVerticalColors = [];\n    this._minHeight = opts.minHeight || 0;\n    this._hasTopBorder = false;\n    this._insideBreak = false;\n    this._startRendering = null;\n  }\n\n  /// private API\n\n  async _pageBreak(level, insideBreak) {\n    this._insideBreak = insideBreak;\n\n    // the pending queue looks as follows: [ [cell1], [cell2], ..., [celln], endRow]\n    // the currently rendered cell is at the head of the queue and therefore removed and\n    // re-inserted at the second last position\n    this._pending.splice(this._pending.length - 2, 0, this._pending.shift());\n\n    // test whether we have rotated all cells of the row\n    if (this._rotated < this._columns - 1) {\n      this._rotated++;\n\n      // move to the next cell\n      this._nextColumn();\n    } else {\n      // execute the pageBreak (rendering background, trigger retrospective page breaks, ...) of all\n      // already ended cells manually\n      for (const cell of this._endedCells) {\n        this._cursor.y = cell._cursor.bottom;\n        await cell._pageBreak(level - 1, insideBreak);\n\n        // pageBreak may add new callbacks to the cell's pending queue, which is however not anymore\n        // contained in the document's queue, therefor add these callbacks to the row's queue\n        while (cell._pending.length) {\n          this._pending.unshift(cell._pending.shift());\n        }\n      }\n      await this._drawBorders(true, insideBreak);\n\n      // reset the rotation\n      this._rotated = 0;\n\n      // execute an actual page break\n      await this._parent._pageBreak(level + 1, insideBreak);\n\n      // store starting y to be able to align all cells horizontally\n      this._y = this._cursor.y;\n      this._endY = null;\n    }\n  }\n  _nextColumn() {\n    // reset the current y back to the row start to align all cells horizontally\n    this._cursor.y = this._y;\n  }\n  async _start() {\n    if (this._minHeight > 0 && !this._parent._cursor.doesFit(this._minHeight)) {\n      await this._parent._pageBreak(1);\n    }\n\n    // save start y of the row to be able to align all cells horizontally\n    this._y = this._cursor.y;\n\n    // block execution until the row knows about all its cells, otherwise it is possible that the\n    // rendering scheduler (_pending) removes this._pending before the cell's end got called\n    if (!this._ended) {\n      await new Promise(resolve => {\n        this._startRendering = resolve;\n      });\n    }\n  }\n  async _end() {\n    // the actual end logic of cells has been postponed until here where it is called manually\n    for (const cell of this._endedCells) {\n      this._cursor.y = this._endY + cell.paddingBottom;\n      await Cell.prototype._end.call(cell);\n    }\n    await this._drawBorders(false);\n\n    // reset cursor\n    this._cursor.x = this._cursor.startX;\n    this._cursor.y = this._endY;\n  }\n  _begin(ctx) {\n    Fragment.prototype._begin.call(this, ctx);\n  }\n  async _drawBorders(isPageBreak, isInsideBreak) {\n    // detect a retrospective page break and not render borders in this case\n    if (isPageBreak && !isInsideBreak) {\n      this._hasTopBorder = true;\n      return;\n    }\n\n    // draw border\n    let hasBorder = false;\n    let chunk = ops.q(); // save graphics state\n\n    const y1 = this._y;\n    const y2 = isPageBreak ? this._cursor.bottom : this._endY;\n    let left = this._cursor.startX;\n    let borderWidth = 0;\n    let borderColor = null;\n    if (this._borderVerticalWidths) {\n      for (let i = 0, len = this._borderVerticalWidths.length; i < len; ++i) {\n        // line width\n        const bw = this._borderVerticalWidths[i];\n        if (bw > 0) {\n          if (borderWidth !== bw) {\n            chunk += ops.w(bw);\n            borderWidth = bw;\n          }\n\n          // stroking color\n          const bc = this._borderVerticalColors[i];\n          if (!borderColor || !util.rgbEqual(borderColor, bc)) {\n            chunk += ops.SC(bc[0], bc[1], bc[2]);\n            borderColor = bc;\n          }\n\n          // fill path\n          let x = left;\n          if (i === 0) {\n            x += bw / 2;\n          } else if (i === len - 1) {\n            x -= bw / 2;\n          }\n          chunk += ops.S(x, y1, \"m\", x, y2, \"l\");\n        }\n        left += this._widths[i];\n      }\n      hasBorder = true;\n    }\n    const totalWidth = this._widths.reduce((lhs, rhs) => lhs + rhs, 0);\n    const x1 = this._cursor.startX;\n    const x2 = x1 + totalWidth;\n    if (this._hasTopBorder && this._topBorderWidth > 0) {\n      this._hasTopBorder = false;\n\n      // line width\n      if (borderWidth !== this._topBorderWidth) {\n        chunk += ops.w(this._topBorderWidth);\n        borderWidth = this._topBorderWidth;\n      }\n\n      // stroking color\n      if (!borderColor || !util.rgbEqual(borderColor, this._topBorderColor)) {\n        chunk += ops.SC(this._topBorderColor[0], this._topBorderColor[1], this._topBorderColor[2]);\n        borderColor = this._topBorderColor;\n      }\n\n      // fill path\n      const y = y1 - this._topBorderWidth / 2;\n      chunk += ops.S(x1, y, \"m\", x2, y, \"l\");\n      hasBorder = true;\n    }\n    if (!isPageBreak && this._bottomBorderWidth > 0) {\n      // line width\n      if (borderWidth !== this._bottomBorderWidth) {\n        chunk += ops.w(this._bottomBorderWidth);\n        borderWidth = this._bottomBorderWidth;\n      }\n\n      // stroking color\n      if (!borderColor || !util.rgbEqual(borderColor, this._bottomBorderColor)) {\n        chunk += ops.SC(this._bottomBorderColor[0], this._bottomBorderColor[1], this._bottomBorderColor[2]);\n        borderColor = this._bottomBorderColor;\n      }\n\n      // fill path\n      const y = y2 + this._bottomBorderWidth / 2;\n      chunk += ops.S(x1, y, \"m\", x2, y, \"l\");\n      hasBorder = true;\n    }\n    if (hasBorder) {\n      chunk += ops.Q(); // restore graphics state\n\n      await this._doc._startContentObject(null, true);\n      await this._doc._write(chunk);\n    }\n  }\n\n  /// public API\n\n  end() {\n    if (this._columns !== this._widths.length) {\n      if (this._columns > this._widths.length) {\n        throw new Error(`Row has ${this.columns} cells but only ${this._widths.length} columns`);\n      }\n\n      // fill missing columns with empty cells\n      for (let i = this.columns; i < this._widths.length; ++i) {\n        this.cell();\n      }\n    }\n    if (this._startRendering) {\n      this._startRendering();\n    }\n    return Fragment.prototype.end.call(this);\n  }\n  cell(text, opts) {\n    // normalize arguments\n    if (text !== null && typeof text === \"object\") {\n      opts = text;\n      text = undefined;\n    }\n    if (!opts || typeof opts !== \"object\") {\n      opts = {};\n    }\n    opts = Object.assign({}, this.opts, opts);\n\n    // create cell and set cell's width according to row options\n    const column = this._columns++;\n    if (!(column in this._widths)) {\n      throw new Error(\"row columns already exceeded, cannot create another cell\");\n    }\n    if (opts.colspan > 1) {\n      for (let i = column + 1, len = column + opts.colspan; i < len; ++i) {\n        if (!(i in this._widths)) {\n          throw new Error(\"row columns already exceeded, colspan to big\");\n        }\n        this._widths[column] += this._widths[i];\n      }\n      this._widths.splice(column + 1, opts.colspan - 1);\n      if (this._borderVerticalWidths) {\n        this._borderVerticalWidths.splice(column + 1, opts.colspan - 1);\n      }\n    }\n    if (opts.minHeight > this._minHeight) {\n      this._minHeight = opts.minHeight;\n    }\n\n    // adjust cell padding to add enough space for borders\n    if (this._borderVerticalWidths) {\n      const borderWidthLeft = this._borderVerticalWidths[column];\n      const borderWidthRight = this._borderVerticalWidths[column + 1];\n      if (borderWidthLeft > 0) {\n        if (column === 0) {\n          // is first\n          opts.borderLeftWidth = borderWidthLeft;\n        } else {\n          opts.borderLeftWidth = borderWidthLeft / 2;\n        }\n      }\n      if (borderWidthRight > 0) {\n        if (column === this._widths.length - 1) {\n          // is last\n          opts.borderRightWidth = borderWidthRight;\n        } else {\n          opts.borderRightWidth = borderWidthRight / 2;\n        }\n      }\n    }\n    if (this._hasTopBorder && this._topBorderWidth > 0) {\n      opts.borderTopWidth = this._topBorderWidth;\n    }\n    if (this._bottomBorderWidth > 0) {\n      opts.borderBottomWidth = this._bottomBorderWidth;\n    }\n    const ctx = new Cell(this._doc, this, Object.assign({}, opts, {\n      width: this._widths[column]\n    }));\n    ctx._drawBorders = false;\n    this._begin(ctx);\n\n    // move the cell to the right by the width of each previous cell\n    for (let i = 0; i < column; ++i) {\n      ctx._cursor.startX += this._widths[i] || 0;\n    }\n    ctx._pending.push(() => ctx._start());\n\n    // override cell's end logic, which is also postponed until the row ends\n    ctx._end = endCell.bind(ctx, this);\n    this._pending.push(ctx._pending);\n    if (typeof text === \"string\" && text.length > 0) {\n      ctx.text(text, opts);\n    }\n    return ctx;\n  }\n};\nasync function endCell(row) {\n  // apply bottom padding\n  this._cursor.y -= this.paddingBottom;\n  const height = this._startY - this._cursor.y;\n  if (height < this.opts.minHeight) {\n    this._cursor.y -= this.opts.minHeight - height;\n  }\n\n  // decrease the counter of active cells\n  row._columns--;\n\n  // reset the parent property, to prevent endless recursion when the pageBreak handler of the\n  // cell is called later on\n  this._parent = null;\n\n  // keep track of the ended cell\n  row._endedCells.push(this);\n\n  // if, last row has been ended, trigger page break manually to continue with other cells on\n  // the next page\n  if (row._columns > 0 && row._rotated === row._columns) {\n    // TODO: level hardcoded?\n    await row._pageBreak(2, row._insideBreak);\n  }\n\n  // keep track of the ending y which is nearest to the page end\n  if (row._endY === null || this._cursor.y < row._endY) {\n    row._endY = this._cursor.y;\n  }\n  this._endLayerRef = this._doc._currentContent;\n\n  // move to the next cell\n  row._nextColumn();\n}","map":{"version":3,"names":["Fragment","require","util","ops","Cell","module","exports","Row","constructor","doc","parent","opts","prototype","_init","call","_pending","_endedCells","_columns","_rotated","_y","_endY","_widths","_topBorderWidth","_topBorderColor","_bottomBorderWidth","_bottomBorderColor","_borderVerticalWidths","_borderVerticalColors","_minHeight","minHeight","_hasTopBorder","_insideBreak","_startRendering","_pageBreak","level","insideBreak","splice","length","shift","_nextColumn","cell","_cursor","y","bottom","unshift","_drawBorders","_parent","_start","doesFit","_ended","Promise","resolve","_end","paddingBottom","x","startX","_begin","ctx","isPageBreak","isInsideBreak","hasBorder","chunk","q","y1","y2","left","borderWidth","borderColor","i","len","bw","w","bc","rgbEqual","SC","S","totalWidth","reduce","lhs","rhs","x1","x2","Q","_doc","_startContentObject","_write","end","Error","columns","text","undefined","Object","assign","column","colspan","borderWidthLeft","borderWidthRight","borderLeftWidth","borderRightWidth","borderTopWidth","borderBottomWidth","width","push","endCell","bind","row","height","_startY","_endLayerRef","_currentContent"],"sources":["C:/xampp/htdocs/stardust/wp-content/themes/stardust-theme/react-src/node_modules/pdfjs/lib/row.js"],"sourcesContent":["\"use strict\";\n\nconst Fragment = require(\"./fragment\");\nconst util = require(\"./util\");\nconst ops = require(\"./ops\");\nconst Cell = require(\"./cell\");\n\nmodule.exports = class Row {\n  constructor(doc, parent, opts) {\n    Fragment.prototype._init.call(this, doc, parent);\n\n    this.opts = opts;\n\n    // use an own queue for pending operations\n    this._pending = [];\n\n    // keep track of the cells that have already been ended;\n    // this is necessary to be able to still draw their background and finalize their rendering\n    // once all cells are ended (scenario where not all cells span the same amount of pages)\n    this._endedCells = [];\n\n    // keep a count of not ended cells to adjust the rotation of cells on page breaks properly\n    this._columns = 0;\n\n    // when a page break occures inside a cell, the cells are rotated before an actual page\n    // break is rendered; i.e., all cells of the row are rendered horizontally\n    this._rotated = 0;\n\n    // this is used to keep track of the starting y of the row to reset the cursor's y to\n    // this value for each cell (since they are horizontally aligned)\n    this._y = 0;\n\n    // on each page the row is rendered on, the row keeps track of the maximal y (or minimum\n    // in terms of PDF, because y 0 is on the bottom) a cell is rendered to, to be able to align\n    // the backgrounds of all cells to the same height\n    this._endY = null;\n\n    this._widths = [];\n    this._topBorderWidth = 0;\n    this._topBorderColor = 0x000000;\n    this._bottomBorderWidth = 0;\n    this._bottomBorderColor = 0x000000;\n    this._borderVerticalWidths = [];\n    this._borderVerticalColors = [];\n    this._minHeight = opts.minHeight || 0;\n\n    this._hasTopBorder = false;\n    this._insideBreak = false;\n    this._startRendering = null;\n  }\n\n  /// private API\n\n  async _pageBreak(level, insideBreak) {\n    this._insideBreak = insideBreak;\n\n    // the pending queue looks as follows: [ [cell1], [cell2], ..., [celln], endRow]\n    // the currently rendered cell is at the head of the queue and therefore removed and\n    // re-inserted at the second last position\n    this._pending.splice(this._pending.length - 2, 0, this._pending.shift());\n\n    // test whether we have rotated all cells of the row\n    if (this._rotated < this._columns - 1) {\n      this._rotated++;\n\n      // move to the next cell\n      this._nextColumn();\n    } else {\n      // execute the pageBreak (rendering background, trigger retrospective page breaks, ...) of all\n      // already ended cells manually\n      for (const cell of this._endedCells) {\n        this._cursor.y = cell._cursor.bottom;\n        await cell._pageBreak(level - 1, insideBreak);\n\n        // pageBreak may add new callbacks to the cell's pending queue, which is however not anymore\n        // contained in the document's queue, therefor add these callbacks to the row's queue\n        while (cell._pending.length) {\n          this._pending.unshift(cell._pending.shift());\n        }\n      }\n\n      await this._drawBorders(true, insideBreak);\n\n      // reset the rotation\n      this._rotated = 0;\n\n      // execute an actual page break\n      await this._parent._pageBreak(level + 1, insideBreak);\n\n      // store starting y to be able to align all cells horizontally\n      this._y = this._cursor.y;\n\n      this._endY = null;\n    }\n  }\n\n  _nextColumn() {\n    // reset the current y back to the row start to align all cells horizontally\n    this._cursor.y = this._y;\n  }\n\n  async _start() {\n    if (this._minHeight > 0 && !this._parent._cursor.doesFit(this._minHeight)) {\n      await this._parent._pageBreak(1);\n    }\n\n    // save start y of the row to be able to align all cells horizontally\n    this._y = this._cursor.y;\n\n    // block execution until the row knows about all its cells, otherwise it is possible that the\n    // rendering scheduler (_pending) removes this._pending before the cell's end got called\n    if (!this._ended) {\n      await new Promise((resolve) => {\n        this._startRendering = resolve;\n      });\n    }\n  }\n\n  async _end() {\n    // the actual end logic of cells has been postponed until here where it is called manually\n    for (const cell of this._endedCells) {\n      this._cursor.y = this._endY + cell.paddingBottom;\n      await Cell.prototype._end.call(cell);\n    }\n\n    await this._drawBorders(false);\n\n    // reset cursor\n    this._cursor.x = this._cursor.startX;\n    this._cursor.y = this._endY;\n  }\n\n  _begin(ctx) {\n    Fragment.prototype._begin.call(this, ctx);\n  }\n\n  async _drawBorders(isPageBreak, isInsideBreak) {\n    // detect a retrospective page break and not render borders in this case\n    if (isPageBreak && !isInsideBreak) {\n      this._hasTopBorder = true;\n      return;\n    }\n\n    // draw border\n    let hasBorder = false;\n    let chunk = ops.q(); // save graphics state\n\n    const y1 = this._y;\n    const y2 = isPageBreak ? this._cursor.bottom : this._endY;\n    let left = this._cursor.startX;\n    let borderWidth = 0;\n    let borderColor = null;\n\n    if (this._borderVerticalWidths) {\n      for (let i = 0, len = this._borderVerticalWidths.length; i < len; ++i) {\n        // line width\n        const bw = this._borderVerticalWidths[i];\n        if (bw > 0) {\n          if (borderWidth !== bw) {\n            chunk += ops.w(bw);\n            borderWidth = bw;\n          }\n\n          // stroking color\n          const bc = this._borderVerticalColors[i];\n          if (!borderColor || !util.rgbEqual(borderColor, bc)) {\n            chunk += ops.SC(bc[0], bc[1], bc[2]);\n            borderColor = bc;\n          }\n\n          // fill path\n          let x = left;\n          if (i === 0) {\n            x += bw / 2;\n          } else if (i === len - 1) {\n            x -= bw / 2;\n          }\n\n          chunk += ops.S(x, y1, \"m\", x, y2, \"l\");\n        }\n\n        left += this._widths[i];\n      }\n\n      hasBorder = true;\n    }\n\n    const totalWidth = this._widths.reduce((lhs, rhs) => lhs + rhs, 0);\n    const x1 = this._cursor.startX;\n    const x2 = x1 + totalWidth;\n\n    if (this._hasTopBorder && this._topBorderWidth > 0) {\n      this._hasTopBorder = false;\n\n      // line width\n      if (borderWidth !== this._topBorderWidth) {\n        chunk += ops.w(this._topBorderWidth);\n        borderWidth = this._topBorderWidth;\n      }\n\n      // stroking color\n      if (!borderColor || !util.rgbEqual(borderColor, this._topBorderColor)) {\n        chunk += ops.SC(\n          this._topBorderColor[0],\n          this._topBorderColor[1],\n          this._topBorderColor[2],\n        );\n        borderColor = this._topBorderColor;\n      }\n\n      // fill path\n      const y = y1 - this._topBorderWidth / 2;\n      chunk += ops.S(x1, y, \"m\", x2, y, \"l\");\n\n      hasBorder = true;\n    }\n\n    if (!isPageBreak && this._bottomBorderWidth > 0) {\n      // line width\n      if (borderWidth !== this._bottomBorderWidth) {\n        chunk += ops.w(this._bottomBorderWidth);\n        borderWidth = this._bottomBorderWidth;\n      }\n\n      // stroking color\n      if (\n        !borderColor ||\n        !util.rgbEqual(borderColor, this._bottomBorderColor)\n      ) {\n        chunk += ops.SC(\n          this._bottomBorderColor[0],\n          this._bottomBorderColor[1],\n          this._bottomBorderColor[2],\n        );\n        borderColor = this._bottomBorderColor;\n      }\n\n      // fill path\n      const y = y2 + this._bottomBorderWidth / 2;\n      chunk += ops.S(x1, y, \"m\", x2, y, \"l\");\n\n      hasBorder = true;\n    }\n\n    if (hasBorder) {\n      chunk += ops.Q(); // restore graphics state\n\n      await this._doc._startContentObject(null, true);\n      await this._doc._write(chunk);\n    }\n  }\n\n  /// public API\n\n  end() {\n    if (this._columns !== this._widths.length) {\n      if (this._columns > this._widths.length) {\n        throw new Error(\n          `Row has ${this.columns} cells but only ${this._widths.length} columns`,\n        );\n      }\n\n      // fill missing columns with empty cells\n      for (let i = this.columns; i < this._widths.length; ++i) {\n        this.cell();\n      }\n    }\n\n    if (this._startRendering) {\n      this._startRendering();\n    }\n    return Fragment.prototype.end.call(this);\n  }\n\n  cell(text, opts) {\n    // normalize arguments\n    if (text !== null && typeof text === \"object\") {\n      opts = text;\n      text = undefined;\n    }\n    if (!opts || typeof opts !== \"object\") {\n      opts = {};\n    }\n\n    opts = Object.assign({}, this.opts, opts);\n\n    // create cell and set cell's width according to row options\n    const column = this._columns++;\n    if (!(column in this._widths)) {\n      throw new Error(\n        \"row columns already exceeded, cannot create another cell\",\n      );\n    }\n\n    if (opts.colspan > 1) {\n      for (let i = column + 1, len = column + opts.colspan; i < len; ++i) {\n        if (!(i in this._widths)) {\n          throw new Error(\"row columns already exceeded, colspan to big\");\n        }\n\n        this._widths[column] += this._widths[i];\n      }\n\n      this._widths.splice(column + 1, opts.colspan - 1);\n\n      if (this._borderVerticalWidths) {\n        this._borderVerticalWidths.splice(column + 1, opts.colspan - 1);\n      }\n    }\n\n    if (opts.minHeight > this._minHeight) {\n      this._minHeight = opts.minHeight;\n    }\n\n    // adjust cell padding to add enough space for borders\n    if (this._borderVerticalWidths) {\n      const borderWidthLeft = this._borderVerticalWidths[column];\n      const borderWidthRight = this._borderVerticalWidths[column + 1];\n\n      if (borderWidthLeft > 0) {\n        if (column === 0) {\n          // is first\n          opts.borderLeftWidth = borderWidthLeft;\n        } else {\n          opts.borderLeftWidth = borderWidthLeft / 2;\n        }\n      }\n\n      if (borderWidthRight > 0) {\n        if (column === this._widths.length - 1) {\n          // is last\n          opts.borderRightWidth = borderWidthRight;\n        } else {\n          opts.borderRightWidth = borderWidthRight / 2;\n        }\n      }\n    }\n\n    if (this._hasTopBorder && this._topBorderWidth > 0) {\n      opts.borderTopWidth = this._topBorderWidth;\n    }\n\n    if (this._bottomBorderWidth > 0) {\n      opts.borderBottomWidth = this._bottomBorderWidth;\n    }\n\n    const ctx = new Cell(\n      this._doc,\n      this,\n      Object.assign({}, opts, {\n        width: this._widths[column],\n      }),\n    );\n    ctx._drawBorders = false;\n\n    this._begin(ctx);\n\n    // move the cell to the right by the width of each previous cell\n    for (let i = 0; i < column; ++i) {\n      ctx._cursor.startX += this._widths[i] || 0;\n    }\n    ctx._pending.push(() => ctx._start());\n\n    // override cell's end logic, which is also postponed until the row ends\n    ctx._end = endCell.bind(ctx, this);\n\n    this._pending.push(ctx._pending);\n\n    if (typeof text === \"string\" && text.length > 0) {\n      ctx.text(text, opts);\n    }\n\n    return ctx;\n  }\n};\n\nasync function endCell(row) {\n  // apply bottom padding\n  this._cursor.y -= this.paddingBottom;\n\n  const height = this._startY - this._cursor.y;\n  if (height < this.opts.minHeight) {\n    this._cursor.y -= this.opts.minHeight - height;\n  }\n\n  // decrease the counter of active cells\n  row._columns--;\n\n  // reset the parent property, to prevent endless recursion when the pageBreak handler of the\n  // cell is called later on\n  this._parent = null;\n\n  // keep track of the ended cell\n  row._endedCells.push(this);\n\n  // if, last row has been ended, trigger page break manually to continue with other cells on\n  // the next page\n  if (row._columns > 0 && row._rotated === row._columns) {\n    // TODO: level hardcoded?\n    await row._pageBreak(2, row._insideBreak);\n  }\n\n  // keep track of the ending y which is nearest to the page end\n  if (row._endY === null || this._cursor.y < row._endY) {\n    row._endY = this._cursor.y;\n  }\n\n  this._endLayerRef = this._doc._currentContent;\n\n  // move to the next cell\n  row._nextColumn();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}