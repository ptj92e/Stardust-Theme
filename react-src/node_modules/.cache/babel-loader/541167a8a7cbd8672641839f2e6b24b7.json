{"ast":null,"code":"\"use strict\";\n\nconst Fragment = require(\"./fragment\");\nconst util = require(\"./util\");\nconst ops = require(\"./ops\");\nmodule.exports = class Cell extends Fragment {\n  constructor(doc, parent, opts) {\n    super(doc, parent);\n    this._pending = [];\n    this._firstPage = true;\n    this._firstRendered = false;\n    this._drawBorders = true;\n\n    // create new cursor for cell context\n    // const previousCursor = this._cursor\n    this._cursor = this._cursor.clone();\n    applyOpts.call(this, opts);\n    this._previousStartX = this._cursor.startX;\n    if (this.x) {\n      this._cursor.startX = this.x;\n    }\n\n    // adjust cursor according to cell padding\n    this._cursor.startX += this.paddingLeft;\n    this._cursor.width -= this.paddingLeft + this.paddingRight;\n    this._cursor.bottomOffset = this.paddingBottom - this.borderBottomWidth;\n    this._startRendering = null;\n  }\n\n  /// private API\n\n  async _pageBreak(level, insideBreak) {\n    const renderHeight = this._startY - this._cursor.bottom;\n    const actualHeight = this._startY - this._cursor.y;\n    let contents, offset;\n    if (!insideBreak && this._firstPage && renderHeight / this._doc.height <= 0.15) {\n      // move already rendered cell content to the next page if the current cell height does only\n      // make up about 10% of the total page height\n      const idx = this._doc._contents.indexOf(this._bgLayerRef);\n      const take = this._endLayerRef ? this._doc._contents.indexOf(this._endLayerRef) - idx + 1 : this._doc._contents.length - idx;\n      contents = this._doc._contents.splice(idx, take);\n      offset = actualHeight - this.paddingTop + this.borderTopWidth;\n    } else {\n      // on page breaks, always draw background until the current bottom\n      this._cursor.y = this._cursor.bottom - this.paddingBottom;\n\n      // create background on each page break\n      await this._createBackground(!this._firstRendered, false);\n      this._firstRendered = true;\n    }\n    this._firstPage = false;\n    if (this._parent) {\n      await this._parent._pageBreak(level + 1, contents === undefined);\n    }\n\n    // By pushing the following at the beginning of the cell's pending queue instead of executing\n    // it directly, we ensure that is executed just before the cell's content continues rendering\n    // on the next page - especially when cells are appended horizontally into rows.\n    this._pending.unshift(async () => {\n      // reset some cursor values\n      this._cursor.x = this._cursor.startX;\n      this._cursor.cursorOffset = 0;\n      if (contents) {\n        await this._doc._startContentObject();\n        await this._doc._write(ops.q() + ops.cm(1, 0, 0, 1, 0, this._cursor.y - this._startY));\n        this._doc._contents.push.apply(this._doc._contents, contents);\n        await this._doc._startContentObject();\n        await this._doc._write(ops.Q());\n        this._bgLayerRef = null;\n      }\n      this._startY = this._cursor.y;\n      if (offset > 0) {\n        this._cursor.y -= offset;\n      }\n\n      // apply padding after page break (but only to most inner cell)\n      if (level === 1) {\n        this._cursor.y -= this.paddingTop - this.borderTopWidth;\n        this._cursor.bottomOffset = this.paddingBottom - this.borderBottomWidth;\n      }\n\n      // TODO: is there a better way of achieving this?\n      if (this._pending.length === 0) {\n        this._cursor.y = this._startY;\n      }\n    });\n  }\n  async _createBackground(hasTopBorder, hasBottomBorder) {\n    // if there is no backgroundColor, it is not necessary to create the background layer\n    const hasBorder = this._drawBorders && (this.borderTopWidth > 0 || this.borderRightWidth > 0 || this.borderBottomWidth > 0 || this.borderLeftWidth > 0);\n    if (!this.backgroundColor && !hasBorder) {\n      return;\n    }\n\n    // start a new content object for the background and border layer\n    await this._doc._startContentObject(null, true);\n\n    // put the background layer behind the cell\n    const layer = this._doc._contents.pop();\n    const bgLayerIndex = this._bgLayerRef ? this._doc._contents.indexOf(this._bgLayerRef) : 0;\n    this._doc._contents.splice(bgLayerIndex, 0, layer);\n\n    // calculate background height\n    let height = this._startY - this._cursor.y;\n    const bottom = this._cursor.bottom - this.paddingBottom + this.borderBottomWidth;\n    if (this._startY - height < bottom) {\n      // if background height goes beyond bottom of document, trim it to the bottom\n      height = this._startY - bottom;\n    }\n    let chunk = ops.q(); // save graphics state\n\n    if (this.backgroundColor) {\n      // write background\n      chunk += ops.sc(this.backgroundColor[0], this.backgroundColor[1], this.backgroundColor[2]) +\n      // non-stroking color\n      ops.re(this._cursor.startX - this.paddingLeft, this._startY - height, this.outerWidth, height) +\n      // rectangle\n      ops.f(); // fill path\n    }\n\n    if (this._drawBorders) {\n      let borderColor = null;\n      let borderWidth = null;\n\n      // draw left border\n      if (this.borderLeftWidth > 0) {\n        if (!borderColor || !util.rgbEqual(borderColor, this.borderLeftColor)) {\n          chunk += ops.SC(this.borderLeftColor[0], this.borderLeftColor[1], this.borderLeftColor[2]); // stroking color\n          borderColor = this.borderLeftColor;\n        }\n        if (borderWidth !== this.borderLeftWidth) {\n          chunk += ops.w(this.borderLeftWidth); // line width\n          borderWidth = this.borderLeftWidth;\n        }\n        const x = this._cursor.startX - this.paddingLeft + this.borderLeftWidth / 2;\n        const y1 = this._startY;\n        const y2 = this._startY - height;\n        chunk += ops.S(x, y1, \"m\", x, y2, \"l\"); // fill path\n      }\n\n      // draw right border\n      if (this.borderRightWidth > 0) {\n        if (!borderColor || !util.rgbEqual(borderColor, this.borderRightColor)) {\n          chunk += ops.SC(this.borderRightColor[0], this.borderRightColor[1], this.borderRightColor[2]); // stroking color\n          borderColor = this.borderRightColor;\n        }\n        if (borderWidth !== this.borderRightWidth) {\n          chunk += ops.w(this.borderRightWidth); // line width\n          borderWidth = this.borderRightWidth;\n        }\n        const x = this._cursor.startX - this.paddingLeft + this.outerWidth - this.borderRightWidth / 2;\n        const y1 = this._startY;\n        const y2 = this._startY - height;\n        chunk += ops.S(x, y1, \"m\", x, y2, \"l\"); // fill path\n      }\n\n      // draw top border\n      if (hasTopBorder && this.borderTopWidth > 0) {\n        if (!borderColor || !util.rgbEqual(borderColor, this.borderTopColor)) {\n          chunk += ops.SC(this.borderTopColor[0], this.borderTopColor[1], this.borderTopColor[2]); // stroking color\n          borderColor = this.borderTopColor;\n        }\n        if (borderWidth !== this.borderTopWidth) {\n          chunk += ops.w(this.borderTopWidth); // line width\n          borderWidth = this.borderTopWidth;\n        }\n        const x1 = this._cursor.startX - this.paddingLeft;\n        const x2 = x1 + this.outerWidth;\n        const y = this._startY - this.borderTopWidth / 2;\n        chunk += ops.S(x1, y, \"m\", x2, y, \"l\"); // fill path\n      }\n\n      // draw bottom border\n      if (hasBottomBorder && this.borderBottomWidth > 0) {\n        if (!borderColor || !util.rgbEqual(borderColor, this.borderBottomColor)) {\n          chunk += ops.SC(this.borderBottomColor[0], this.borderBottomColor[1], this.borderBottomColor[2]); // stroking color\n          borderColor = this.borderBottomColor;\n        }\n        if (borderWidth !== this.borderBottomWidth) {\n          chunk += ops.w(this.borderBottomWidth); // line width\n          borderWidth = this.borderBottomWidth;\n        }\n        const x1 = this._cursor.startX - this.paddingLeft;\n        const x2 = x1 + this.outerWidth;\n        const y = this._startY - height + this.borderBottomWidth / 2;\n        chunk += ops.S(x1, y, \"m\", x2, y, \"l\"); // fill path\n      }\n    }\n\n    if (chunk.length > 0) {\n      chunk += ops.Q(); // restore graphics state\n      await this._doc._write(chunk);\n    }\n\n    // for succeeding pages put background layers at index 0 (for bgLayerRef === null, index 0\n    // will be used)\n    this._bgLayerRef = null;\n\n    // update startAt to take page break into account\n    this._startY = this._cursor.startY;\n  }\n  async _start() {\n    if (!this._doc._currentContent) {\n      await this._doc._startPage();\n    }\n    if (this.minHeight > 0 && !this._parent._cursor.doesFit(this.minHeight)) {\n      await this._parent._pageBreak(1);\n    }\n    if (this.y !== undefined) {\n      this._cursor.y = this.y;\n    }\n\n    // Note: We could call `doesFit(this.minHeight)` here again to test whether the cell fits on the\n    // newly created page. However, instead of throwing an error, when the minHeight is greater than\n    // the document height, the minHeight is bounded to the documents height.\n\n    this._startY = this._cursor.y;\n    this._cursor.x = this._cursor.startX;\n    this._cursor.y -= this.paddingTop;\n    this.outerWidth = this._cursor.width + this.paddingLeft + this.paddingRight;\n\n    // start a new content layer for cells\n    // save the current layer ref, this will be used to place the background and border layer\n    // after the cell has been rendered\n    // Note: saving the index directly would  not work for nested rendering tasks\n    this._bgLayerRef = await this._doc._startContentObject(null, true);\n\n    // block execution until the row knows about all its cells, otherwise it is possible that the\n    // rendering scheduler (_pending) removes this._pending before the cell's end got called\n    if (!this._ended) {\n      await new Promise(resolve => {\n        this._startRendering = resolve;\n      });\n    }\n  }\n  async _end() {\n    // apply bottom padding\n    this._cursor.y -= this.paddingBottom;\n    const height = this._startY - this._cursor.y;\n    if (height < this.opts.minHeight) {\n      this._cursor.y -= this.opts.minHeight - height;\n    }\n\n    // create final createBackground\n    await this._createBackground(!this._firstRendered, true);\n\n    // restore cursor\n    this._cursor.x = this._previousStartX;\n  }\n  end() {\n    if (this._startRendering) {\n      this._startRendering();\n    }\n    return Fragment.prototype.end.call(this);\n  }\n};\nfunction applyOpts(opts) {\n  this.opts = opts;\n  if (\"width\" in opts) {\n    this._cursor.width = opts.width;\n  }\n  if (\"x\" in opts) {\n    this.x = opts.x;\n  }\n  if (\"y\" in opts) {\n    this.y = opts.y;\n  }\n  this.paddingTop = opts.paddingTop || opts.padding || 0;\n  this.paddingRight = opts.paddingRight || opts.padding || 0;\n  this.paddingBottom = opts.paddingBottom || opts.padding || 0;\n  this.paddingLeft = opts.paddingLeft || opts.padding || 0;\n\n  // background creation callback\n  this.backgroundColor = util.colorToRgb(opts.backgroundColor);\n  this.borderTopWidth = opts.borderTopWidth || opts.borderWidth || 0;\n  this.borderTopColor = util.colorToRgb(opts.borderTopColor || opts.borderColor || 0x000000);\n  this.borderRightWidth = opts.borderRightWidth || opts.borderWidth || 0;\n  this.borderRightColor = util.colorToRgb(opts.borderRightColor || opts.borderColor || 0x000000);\n  this.borderBottomWidth = opts.borderBottomWidth || opts.borderWidth || 0;\n  this.borderBottomColor = util.colorToRgb(opts.borderBottomColor || opts.borderColor || 0x000000);\n  this.borderLeftWidth = opts.borderLeftWidth || opts.borderWidth || 0;\n  this.borderLeftColor = util.colorToRgb(opts.borderLeftColor || opts.borderColor || 0x000000);\n  this.paddingTop += this.borderTopWidth;\n  this.paddingRight += this.borderRightWidth;\n  this.paddingBottom += this.borderBottomWidth;\n  this.paddingLeft += this.borderLeftWidth;\n  this.minHeight = opts.minHeight || 0;\n}","map":{"version":3,"names":["Fragment","require","util","ops","module","exports","Cell","constructor","doc","parent","opts","_pending","_firstPage","_firstRendered","_drawBorders","_cursor","clone","applyOpts","call","_previousStartX","startX","x","paddingLeft","width","paddingRight","bottomOffset","paddingBottom","borderBottomWidth","_startRendering","_pageBreak","level","insideBreak","renderHeight","_startY","bottom","actualHeight","y","contents","offset","_doc","height","idx","_contents","indexOf","_bgLayerRef","take","_endLayerRef","length","splice","paddingTop","borderTopWidth","_createBackground","_parent","undefined","unshift","cursorOffset","_startContentObject","_write","q","cm","push","apply","Q","hasTopBorder","hasBottomBorder","hasBorder","borderRightWidth","borderLeftWidth","backgroundColor","layer","pop","bgLayerIndex","chunk","sc","re","outerWidth","f","borderColor","borderWidth","rgbEqual","borderLeftColor","SC","w","y1","y2","S","borderRightColor","borderTopColor","x1","x2","borderBottomColor","startY","_start","_currentContent","_startPage","minHeight","doesFit","_ended","Promise","resolve","_end","end","prototype","padding","colorToRgb"],"sources":["C:/xampp/htdocs/stardust/wp-content/themes/stardust-theme/react-src/node_modules/pdfjs/lib/cell.js"],"sourcesContent":["\"use strict\";\n\nconst Fragment = require(\"./fragment\");\nconst util = require(\"./util\");\nconst ops = require(\"./ops\");\n\nmodule.exports = class Cell extends Fragment {\n  constructor(doc, parent, opts) {\n    super(doc, parent);\n\n    this._pending = [];\n    this._firstPage = true;\n    this._firstRendered = false;\n    this._drawBorders = true;\n\n    // create new cursor for cell context\n    // const previousCursor = this._cursor\n    this._cursor = this._cursor.clone();\n\n    applyOpts.call(this, opts);\n\n    this._previousStartX = this._cursor.startX;\n    if (this.x) {\n      this._cursor.startX = this.x;\n    }\n\n    // adjust cursor according to cell padding\n    this._cursor.startX += this.paddingLeft;\n    this._cursor.width -= this.paddingLeft + this.paddingRight;\n    this._cursor.bottomOffset = this.paddingBottom - this.borderBottomWidth;\n\n    this._startRendering = null;\n  }\n\n  /// private API\n\n  async _pageBreak(level, insideBreak) {\n    const renderHeight = this._startY - this._cursor.bottom;\n    const actualHeight = this._startY - this._cursor.y;\n\n    let contents, offset;\n    if (\n      !insideBreak &&\n      this._firstPage &&\n      renderHeight / this._doc.height <= 0.15\n    ) {\n      // move already rendered cell content to the next page if the current cell height does only\n      // make up about 10% of the total page height\n      const idx = this._doc._contents.indexOf(this._bgLayerRef);\n      const take = this._endLayerRef\n        ? this._doc._contents.indexOf(this._endLayerRef) - idx + 1\n        : this._doc._contents.length - idx;\n      contents = this._doc._contents.splice(idx, take);\n      offset = actualHeight - this.paddingTop + this.borderTopWidth;\n    } else {\n      // on page breaks, always draw background until the current bottom\n      this._cursor.y = this._cursor.bottom - this.paddingBottom;\n\n      // create background on each page break\n      await this._createBackground(!this._firstRendered, false);\n      this._firstRendered = true;\n    }\n\n    this._firstPage = false;\n\n    if (this._parent) {\n      await this._parent._pageBreak(level + 1, contents === undefined);\n    }\n\n    // By pushing the following at the beginning of the cell's pending queue instead of executing\n    // it directly, we ensure that is executed just before the cell's content continues rendering\n    // on the next page - especially when cells are appended horizontally into rows.\n    this._pending.unshift(async () => {\n      // reset some cursor values\n      this._cursor.x = this._cursor.startX;\n      this._cursor.cursorOffset = 0;\n\n      if (contents) {\n        await this._doc._startContentObject();\n        await this._doc._write(\n          ops.q() + ops.cm(1, 0, 0, 1, 0, this._cursor.y - this._startY),\n        );\n        this._doc._contents.push.apply(this._doc._contents, contents);\n\n        await this._doc._startContentObject();\n        await this._doc._write(ops.Q());\n\n        this._bgLayerRef = null;\n      }\n\n      this._startY = this._cursor.y;\n\n      if (offset > 0) {\n        this._cursor.y -= offset;\n      }\n\n      // apply padding after page break (but only to most inner cell)\n      if (level === 1) {\n        this._cursor.y -= this.paddingTop - this.borderTopWidth;\n        this._cursor.bottomOffset = this.paddingBottom - this.borderBottomWidth;\n      }\n\n      // TODO: is there a better way of achieving this?\n      if (this._pending.length === 0) {\n        this._cursor.y = this._startY;\n      }\n    });\n  }\n\n  async _createBackground(hasTopBorder, hasBottomBorder) {\n    // if there is no backgroundColor, it is not necessary to create the background layer\n    const hasBorder =\n      this._drawBorders &&\n      (this.borderTopWidth > 0 ||\n        this.borderRightWidth > 0 ||\n        this.borderBottomWidth > 0 ||\n        this.borderLeftWidth > 0);\n    if (!this.backgroundColor && !hasBorder) {\n      return;\n    }\n\n    // start a new content object for the background and border layer\n    await this._doc._startContentObject(null, true);\n\n    // put the background layer behind the cell\n    const layer = this._doc._contents.pop();\n    const bgLayerIndex = this._bgLayerRef\n      ? this._doc._contents.indexOf(this._bgLayerRef)\n      : 0;\n    this._doc._contents.splice(bgLayerIndex, 0, layer);\n\n    // calculate background height\n    let height = this._startY - this._cursor.y;\n    const bottom =\n      this._cursor.bottom - this.paddingBottom + this.borderBottomWidth;\n    if (this._startY - height < bottom) {\n      // if background height goes beyond bottom of document, trim it to the bottom\n      height = this._startY - bottom;\n    }\n\n    let chunk = ops.q(); // save graphics state\n\n    if (this.backgroundColor) {\n      // write background\n      chunk +=\n        ops.sc(\n          this.backgroundColor[0],\n          this.backgroundColor[1],\n          this.backgroundColor[2],\n        ) + // non-stroking color\n        ops.re(\n          this._cursor.startX - this.paddingLeft,\n          this._startY - height,\n          this.outerWidth,\n          height,\n        ) + // rectangle\n        ops.f(); // fill path\n    }\n\n    if (this._drawBorders) {\n      let borderColor = null;\n      let borderWidth = null;\n\n      // draw left border\n      if (this.borderLeftWidth > 0) {\n        if (!borderColor || !util.rgbEqual(borderColor, this.borderLeftColor)) {\n          chunk += ops.SC(\n            this.borderLeftColor[0],\n            this.borderLeftColor[1],\n            this.borderLeftColor[2],\n          ); // stroking color\n          borderColor = this.borderLeftColor;\n        }\n\n        if (borderWidth !== this.borderLeftWidth) {\n          chunk += ops.w(this.borderLeftWidth); // line width\n          borderWidth = this.borderLeftWidth;\n        }\n\n        const x =\n          this._cursor.startX - this.paddingLeft + this.borderLeftWidth / 2;\n        const y1 = this._startY;\n        const y2 = this._startY - height;\n\n        chunk += ops.S(x, y1, \"m\", x, y2, \"l\"); // fill path\n      }\n\n      // draw right border\n      if (this.borderRightWidth > 0) {\n        if (\n          !borderColor ||\n          !util.rgbEqual(borderColor, this.borderRightColor)\n        ) {\n          chunk += ops.SC(\n            this.borderRightColor[0],\n            this.borderRightColor[1],\n            this.borderRightColor[2],\n          ); // stroking color\n          borderColor = this.borderRightColor;\n        }\n\n        if (borderWidth !== this.borderRightWidth) {\n          chunk += ops.w(this.borderRightWidth); // line width\n          borderWidth = this.borderRightWidth;\n        }\n\n        const x =\n          this._cursor.startX -\n          this.paddingLeft +\n          this.outerWidth -\n          this.borderRightWidth / 2;\n        const y1 = this._startY;\n        const y2 = this._startY - height;\n\n        chunk += ops.S(x, y1, \"m\", x, y2, \"l\"); // fill path\n      }\n\n      // draw top border\n      if (hasTopBorder && this.borderTopWidth > 0) {\n        if (!borderColor || !util.rgbEqual(borderColor, this.borderTopColor)) {\n          chunk += ops.SC(\n            this.borderTopColor[0],\n            this.borderTopColor[1],\n            this.borderTopColor[2],\n          ); // stroking color\n          borderColor = this.borderTopColor;\n        }\n\n        if (borderWidth !== this.borderTopWidth) {\n          chunk += ops.w(this.borderTopWidth); // line width\n          borderWidth = this.borderTopWidth;\n        }\n\n        const x1 = this._cursor.startX - this.paddingLeft;\n        const x2 = x1 + this.outerWidth;\n        const y = this._startY - this.borderTopWidth / 2;\n\n        chunk += ops.S(x1, y, \"m\", x2, y, \"l\"); // fill path\n      }\n\n      // draw bottom border\n      if (hasBottomBorder && this.borderBottomWidth > 0) {\n        if (\n          !borderColor ||\n          !util.rgbEqual(borderColor, this.borderBottomColor)\n        ) {\n          chunk += ops.SC(\n            this.borderBottomColor[0],\n            this.borderBottomColor[1],\n            this.borderBottomColor[2],\n          ); // stroking color\n          borderColor = this.borderBottomColor;\n        }\n\n        if (borderWidth !== this.borderBottomWidth) {\n          chunk += ops.w(this.borderBottomWidth); // line width\n          borderWidth = this.borderBottomWidth;\n        }\n\n        const x1 = this._cursor.startX - this.paddingLeft;\n        const x2 = x1 + this.outerWidth;\n        const y = this._startY - height + this.borderBottomWidth / 2;\n\n        chunk += ops.S(x1, y, \"m\", x2, y, \"l\"); // fill path\n      }\n    }\n\n    if (chunk.length > 0) {\n      chunk += ops.Q(); // restore graphics state\n      await this._doc._write(chunk);\n    }\n\n    // for succeeding pages put background layers at index 0 (for bgLayerRef === null, index 0\n    // will be used)\n    this._bgLayerRef = null;\n\n    // update startAt to take page break into account\n    this._startY = this._cursor.startY;\n  }\n\n  async _start() {\n    if (!this._doc._currentContent) {\n      await this._doc._startPage();\n    }\n\n    if (this.minHeight > 0 && !this._parent._cursor.doesFit(this.minHeight)) {\n      await this._parent._pageBreak(1);\n    }\n\n    if (this.y !== undefined) {\n      this._cursor.y = this.y;\n    }\n\n    // Note: We could call `doesFit(this.minHeight)` here again to test whether the cell fits on the\n    // newly created page. However, instead of throwing an error, when the minHeight is greater than\n    // the document height, the minHeight is bounded to the documents height.\n\n    this._startY = this._cursor.y;\n\n    this._cursor.x = this._cursor.startX;\n    this._cursor.y -= this.paddingTop;\n\n    this.outerWidth = this._cursor.width + this.paddingLeft + this.paddingRight;\n\n    // start a new content layer for cells\n    // save the current layer ref, this will be used to place the background and border layer\n    // after the cell has been rendered\n    // Note: saving the index directly would  not work for nested rendering tasks\n    this._bgLayerRef = await this._doc._startContentObject(null, true);\n\n    // block execution until the row knows about all its cells, otherwise it is possible that the\n    // rendering scheduler (_pending) removes this._pending before the cell's end got called\n    if (!this._ended) {\n      await new Promise((resolve) => {\n        this._startRendering = resolve;\n      });\n    }\n  }\n\n  async _end() {\n    // apply bottom padding\n    this._cursor.y -= this.paddingBottom;\n\n    const height = this._startY - this._cursor.y;\n    if (height < this.opts.minHeight) {\n      this._cursor.y -= this.opts.minHeight - height;\n    }\n\n    // create final createBackground\n    await this._createBackground(!this._firstRendered, true);\n\n    // restore cursor\n    this._cursor.x = this._previousStartX;\n  }\n\n  end() {\n    if (this._startRendering) {\n      this._startRendering();\n    }\n    return Fragment.prototype.end.call(this);\n  }\n};\n\nfunction applyOpts(opts) {\n  this.opts = opts;\n\n  if (\"width\" in opts) {\n    this._cursor.width = opts.width;\n  }\n\n  if (\"x\" in opts) {\n    this.x = opts.x;\n  }\n\n  if (\"y\" in opts) {\n    this.y = opts.y;\n  }\n\n  this.paddingTop = opts.paddingTop || opts.padding || 0;\n  this.paddingRight = opts.paddingRight || opts.padding || 0;\n  this.paddingBottom = opts.paddingBottom || opts.padding || 0;\n  this.paddingLeft = opts.paddingLeft || opts.padding || 0;\n\n  // background creation callback\n  this.backgroundColor = util.colorToRgb(opts.backgroundColor);\n\n  this.borderTopWidth = opts.borderTopWidth || opts.borderWidth || 0;\n  this.borderTopColor = util.colorToRgb(\n    opts.borderTopColor || opts.borderColor || 0x000000,\n  );\n\n  this.borderRightWidth = opts.borderRightWidth || opts.borderWidth || 0;\n  this.borderRightColor = util.colorToRgb(\n    opts.borderRightColor || opts.borderColor || 0x000000,\n  );\n\n  this.borderBottomWidth = opts.borderBottomWidth || opts.borderWidth || 0;\n  this.borderBottomColor = util.colorToRgb(\n    opts.borderBottomColor || opts.borderColor || 0x000000,\n  );\n\n  this.borderLeftWidth = opts.borderLeftWidth || opts.borderWidth || 0;\n  this.borderLeftColor = util.colorToRgb(\n    opts.borderLeftColor || opts.borderColor || 0x000000,\n  );\n\n  this.paddingTop += this.borderTopWidth;\n  this.paddingRight += this.borderRightWidth;\n  this.paddingBottom += this.borderBottomWidth;\n  this.paddingLeft += this.borderLeftWidth;\n\n  this.minHeight = opts.minHeight || 0;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}