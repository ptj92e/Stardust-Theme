{"ast":null,"code":"\"use strict\";\n\nconst Lexer = require(\"./lexer\");\nconst PDF = require(\"../object\");\nconst util = require(\"../util\");\nclass Parser {\n  // ab ... ArrayBuffer\n  constructor(ab) {\n    this.src = new Uint8Array(util.toArrayBuffer(ab));\n  }\n  parse() {\n    let index = lastIndexOf(this.src, \"startxref\", 128);\n    if (index === -1) {\n      throw new Error(\"Invalid PDF: startxref not found\");\n    }\n    index += \"startxref\".length;\n\n    // skip whitespaces\n    while (Lexer.isWhiteSpace(this.src[++index])) {}\n    let str = \"\";\n    while (this.src[index] >= 0x30 && this.src[index] <= 0x39) {\n      // between 0 and 9\n      str += String.fromCharCode(this.src[index++]);\n    }\n    const startXRef = parseInt(str, 10);\n    if (isNaN(startXRef)) {\n      throw new Error(\"Invalid PDF: startxref is not a number\");\n    }\n    const lexer = new Lexer(this.src);\n    lexer.shift(startXRef);\n    this.xref = PDF.Xref.parse(null, lexer);\n    this.trailer = this.xref.trailer || PDF.Trailer.parse(this.xref, lexer);\n    let trailer = this.trailer;\n    while (trailer.has(\"Prev\")) {\n      const prevTrailerPos = trailer.get(\"Prev\");\n      // Ignore prev pointers to the document beginning. This is not according to the PDF spec, but\n      // there are PDFs out there doing it anyway.\n      if (prevTrailerPos === 0) {\n        break;\n      }\n      lexer.pos = trailer.get(\"Prev\");\n      const xref = PDF.Xref.parse(null, lexer);\n      for (let i = 0; i < xref.objects.length; ++i) {\n        const obj = xref.objects[i];\n        if (obj && !this.xref.objects[i]) {\n          this.xref.objects[i] = obj;\n        }\n      }\n      trailer = xref.trailer || PDF.Trailer.parse(xref, lexer);\n    }\n  }\n  static addObjectsRecursive(objects, value) {\n    switch (true) {\n      case value instanceof PDF.Reference:\n        if (objects.indexOf(value.object) > -1) {\n          break;\n        }\n        objects.push(value.object);\n        Parser.addObjectsRecursive(objects, value.object);\n        break;\n      case value instanceof PDF.Object:\n        Parser.addObjectsRecursive(objects, value.properties);\n        Parser.addObjectsRecursive(objects, value.content);\n        break;\n      case value instanceof PDF.Dictionary:\n        for (const key in value.dictionary) {\n          if (key === \"/Parent\") {\n            // ignore parent property to prevent moving above Page objects\n            continue;\n          }\n          Parser.addObjectsRecursive(objects, value.dictionary[key]);\n        }\n        break;\n      case Array.isArray(value):\n        value.forEach(function (item) {\n          Parser.addObjectsRecursive(objects, item);\n        });\n        break;\n    }\n  }\n}\nmodule.exports = Parser;\nfunction lastIndexOf(src, key, step) {\n  if (!step) step = 1024;\n  let pos = src.length,\n    index = -1;\n  while (index === -1 && pos > 0) {\n    pos -= step - key.length;\n    index = find(src, key, Math.max(pos, 0), step, true);\n  }\n  return index;\n}\nfunction find(src, key, pos, limit, backwards) {\n  if (pos + limit > src.length) {\n    limit = src.length - pos;\n  }\n  const str = String.fromCharCode.apply(null, src.subarray(pos, pos + limit));\n  let index = backwards ? str.lastIndexOf(key) : str.indexOf(key);\n  if (index > -1) {\n    index += pos;\n  }\n  return index;\n}","map":{"version":3,"names":["Lexer","require","PDF","util","Parser","constructor","ab","src","Uint8Array","toArrayBuffer","parse","index","lastIndexOf","Error","length","isWhiteSpace","str","String","fromCharCode","startXRef","parseInt","isNaN","lexer","shift","xref","Xref","trailer","Trailer","has","prevTrailerPos","get","pos","i","objects","obj","addObjectsRecursive","value","Reference","indexOf","object","push","Object","properties","content","Dictionary","key","dictionary","Array","isArray","forEach","item","module","exports","step","find","Math","max","limit","backwards","apply","subarray"],"sources":["C:/xampp/htdocs/stardust/wp-content/themes/stardust-theme/react-src/node_modules/pdfjs/lib/parser/parser.js"],"sourcesContent":["\"use strict\";\n\nconst Lexer = require(\"./lexer\");\nconst PDF = require(\"../object\");\nconst util = require(\"../util\");\n\nclass Parser {\n  // ab ... ArrayBuffer\n  constructor(ab) {\n    this.src = new Uint8Array(util.toArrayBuffer(ab));\n  }\n\n  parse() {\n    let index = lastIndexOf(this.src, \"startxref\", 128);\n    if (index === -1) {\n      throw new Error(\"Invalid PDF: startxref not found\");\n    }\n\n    index += \"startxref\".length;\n\n    // skip whitespaces\n    while (Lexer.isWhiteSpace(this.src[++index])) {}\n\n    let str = \"\";\n    while (this.src[index] >= 0x30 && this.src[index] <= 0x39) {\n      // between 0 and 9\n      str += String.fromCharCode(this.src[index++]);\n    }\n\n    const startXRef = parseInt(str, 10);\n\n    if (isNaN(startXRef)) {\n      throw new Error(\"Invalid PDF: startxref is not a number\");\n    }\n\n    const lexer = new Lexer(this.src);\n    lexer.shift(startXRef);\n\n    this.xref = PDF.Xref.parse(null, lexer);\n    this.trailer = this.xref.trailer || PDF.Trailer.parse(this.xref, lexer);\n\n    let trailer = this.trailer;\n    while (trailer.has(\"Prev\")) {\n      const prevTrailerPos = trailer.get(\"Prev\");\n      // Ignore prev pointers to the document beginning. This is not according to the PDF spec, but\n      // there are PDFs out there doing it anyway.\n      if (prevTrailerPos === 0) {\n        break;\n      }\n\n      lexer.pos = trailer.get(\"Prev\");\n      const xref = PDF.Xref.parse(null, lexer);\n\n      for (let i = 0; i < xref.objects.length; ++i) {\n        const obj = xref.objects[i];\n        if (obj && !this.xref.objects[i]) {\n          this.xref.objects[i] = obj;\n        }\n      }\n\n      trailer = xref.trailer || PDF.Trailer.parse(xref, lexer);\n    }\n  }\n\n  static addObjectsRecursive(objects, value) {\n    switch (true) {\n      case value instanceof PDF.Reference:\n        if (objects.indexOf(value.object) > -1) {\n          break;\n        }\n        objects.push(value.object);\n        Parser.addObjectsRecursive(objects, value.object);\n        break;\n      case value instanceof PDF.Object:\n        Parser.addObjectsRecursive(objects, value.properties);\n        Parser.addObjectsRecursive(objects, value.content);\n        break;\n      case value instanceof PDF.Dictionary:\n        for (const key in value.dictionary) {\n          if (key === \"/Parent\") {\n            // ignore parent property to prevent moving above Page objects\n            continue;\n          }\n          Parser.addObjectsRecursive(objects, value.dictionary[key]);\n        }\n        break;\n      case Array.isArray(value):\n        value.forEach(function (item) {\n          Parser.addObjectsRecursive(objects, item);\n        });\n        break;\n    }\n  }\n}\n\nmodule.exports = Parser;\n\nfunction lastIndexOf(src, key, step) {\n  if (!step) step = 1024;\n  let pos = src.length,\n    index = -1;\n\n  while (index === -1 && pos > 0) {\n    pos -= step - key.length;\n    index = find(src, key, Math.max(pos, 0), step, true);\n  }\n\n  return index;\n}\n\nfunction find(src, key, pos, limit, backwards) {\n  if (pos + limit > src.length) {\n    limit = src.length - pos;\n  }\n\n  const str = String.fromCharCode.apply(null, src.subarray(pos, pos + limit));\n  let index = backwards ? str.lastIndexOf(key) : str.indexOf(key);\n  if (index > -1) {\n    index += pos;\n  }\n  return index;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}