{"ast":null,"code":"\"use strict\";\n\nconst Lexer = require(\"../parser/lexer\");\nclass PDFString {\n  constructor(str) {\n    this.str = str;\n  }\n  toHexString() {\n    // convert to hex string\n    let hex = \"\";\n    for (let i = 0, len = this.str.length; i < len; ++i) {\n      let h = (this.str.charCodeAt(i) - 31).toString(16);\n      // left pad zeroes\n      h = (\"0000\" + h).slice(-4);\n      hex += h;\n    }\n    return \"<\" + hex + \">\";\n  }\n  toString() {\n    return \"(\" + this.str.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\(/g, \"\\\\(\").replace(/\\)/g, \"\\\\)\") + \")\";\n  }\n  static parse(xref, lexer, trial) {\n    const literal = PDFString.parseLiteral(lexer, trial);\n    const hex = literal === undefined && PDFString.parseHex(lexer, trial);\n    if (!literal && !hex) {\n      if (trial) {\n        return undefined;\n      }\n      throw new Error(\"Invalid string\");\n    }\n    return literal || hex;\n  }\n  static parseLiteral(lexer, trial) {\n    if (lexer.getString(1) !== \"(\") {\n      if (trial) {\n        return undefined;\n      }\n      throw new Error(\"Invalid literal string\");\n    }\n    lexer.shift(1);\n    let str = \"\";\n    let done = false;\n    let open = 0;\n    let c;\n    while (!done && (c = lexer._nextCharCode()) >= 0) {\n      switch (c) {\n        case 0x28:\n          // (\n          open++;\n          str += String.fromCharCode(\"(\");\n          break;\n        case 0x29:\n          // )\n          if (open === 0) {\n            done = true;\n          } else {\n            open--;\n            str += String.fromCharCode(\")\");\n          }\n          break;\n        case 0x5c:\n          // \\\n          c = lexer._nextCharCode();\n          switch (c) {\n            case 0x6e:\n              // \\n\n              str += \"\\n\";\n              break;\n            case 0x72:\n              // \\r\n              str += \"\\r\";\n              break;\n            case 0x74:\n              // \\t\n              str += \"\\t\";\n              break;\n            case 0x62:\n              // \\b\n              str += \"\\b\";\n              break;\n            case 0x66:\n              // \\f\n              str += \"\\f\";\n              break;\n            case 0x28: // '('\n            case 0x29: // ')'\n            case 0x5c:\n              // '\\'\n              str += String.fromCharCode(c);\n              break;\n            case 0x30: // 0\n            case 0x31: // 1\n            case 0x32: // 2\n            case 0x33: // 3\n            case 0x34: // 4\n            case 0x35: // 5\n            case 0x36: // 6\n            case 0x37: // 7\n            case 0x38: // 8\n            case 0x39:\n              // 9\n              const oct = String.fromCharCode(c) + lexer.readString(2);\n              str += String.fromCharCode(parseInt(oct, 8));\n              break;\n            default:\n              lexer.shift(-1);\n              break;\n          }\n          break;\n        case 0x0d: // CR\n        case 0x0a:\n          // LF\n          // ignore EOL characters\n          break;\n        default:\n          str += String.fromCharCode(c);\n          break;\n      }\n    }\n    return new PDFString(str);\n  }\n  static parseHex(lexer, trial) {\n    if (lexer.getString(1) !== \"<\") {\n      if (trial) {\n        return undefined;\n      }\n      throw new Error(\"Invalid hex string\");\n    }\n    lexer.shift(1);\n    let str = \"\";\n    let done = false;\n    const digits = [];\n    const addCharacter = function (force) {\n      if (digits.length !== 2) {\n        if (digits.length === 1 && force) {\n          digits.push(\"0\");\n        } else {\n          return;\n        }\n      }\n      str += String.fromCharCode(parseInt(digits.join(\"\"), 16));\n      digits.length = 0;\n    };\n    let c;\n    while (!done && (c = lexer._nextCharCode()) >= 0) {\n      switch (true) {\n        case c === 0x3e:\n          // >\n          done = true;\n          break;\n        case c >= 0x30 && c <= 0x39: // 0 - 9\n        case c >= 0x41 && c <= 0x5a: // A - B\n        case c >= 0x61 && c <= 0x7a:\n          // a - b\n          digits.push(String.fromCharCode(c));\n          addCharacter();\n          break;\n        case Lexer.isWhiteSpace(c):\n          break;\n        default:\n          lexer._warning(\"invalid character `\" + String.fromCharCode(c) + \"` in hex string\");\n          break;\n      }\n    }\n    addCharacter(true);\n    return new PDFString(str);\n  }\n}\nmodule.exports = PDFString;","map":{"version":3,"names":["Lexer","require","PDFString","constructor","str","toHexString","hex","i","len","length","h","charCodeAt","toString","slice","replace","parse","xref","lexer","trial","literal","parseLiteral","undefined","parseHex","Error","getString","shift","done","open","c","_nextCharCode","String","fromCharCode","oct","readString","parseInt","digits","addCharacter","force","push","join","isWhiteSpace","_warning","module","exports"],"sources":["C:/xampp/htdocs/stardust/wp-content/themes/stardust-theme/react-src/node_modules/pdfjs/lib/object/string.js"],"sourcesContent":["\"use strict\";\n\nconst Lexer = require(\"../parser/lexer\");\n\nclass PDFString {\n  constructor(str) {\n    this.str = str;\n  }\n\n  toHexString() {\n    // convert to hex string\n    let hex = \"\";\n    for (let i = 0, len = this.str.length; i < len; ++i) {\n      let h = (this.str.charCodeAt(i) - 31).toString(16);\n      // left pad zeroes\n      h = (\"0000\" + h).slice(-4);\n      hex += h;\n    }\n    return \"<\" + hex + \">\";\n  }\n\n  toString() {\n    return (\n      \"(\" +\n      this.str\n        .replace(/\\\\/g, \"\\\\\\\\\")\n        .replace(/\\(/g, \"\\\\(\")\n        .replace(/\\)/g, \"\\\\)\") +\n      \")\"\n    );\n  }\n\n  static parse(xref, lexer, trial) {\n    const literal = PDFString.parseLiteral(lexer, trial);\n    const hex = literal === undefined && PDFString.parseHex(lexer, trial);\n\n    if (!literal && !hex) {\n      if (trial) {\n        return undefined;\n      }\n\n      throw new Error(\"Invalid string\");\n    }\n\n    return literal || hex;\n  }\n\n  static parseLiteral(lexer, trial) {\n    if (lexer.getString(1) !== \"(\") {\n      if (trial) {\n        return undefined;\n      }\n\n      throw new Error(\"Invalid literal string\");\n    }\n\n    lexer.shift(1);\n\n    let str = \"\";\n\n    let done = false;\n    let open = 0;\n    let c;\n    while (!done && (c = lexer._nextCharCode()) >= 0) {\n      switch (c) {\n        case 0x28: // (\n          open++;\n          str += String.fromCharCode(\"(\");\n          break;\n        case 0x29: // )\n          if (open === 0) {\n            done = true;\n          } else {\n            open--;\n            str += String.fromCharCode(\")\");\n          }\n          break;\n        case 0x5c: // \\\n          c = lexer._nextCharCode();\n          switch (c) {\n            case 0x6e: // \\n\n              str += \"\\n\";\n              break;\n            case 0x72: // \\r\n              str += \"\\r\";\n              break;\n            case 0x74: // \\t\n              str += \"\\t\";\n              break;\n            case 0x62: // \\b\n              str += \"\\b\";\n              break;\n            case 0x66: // \\f\n              str += \"\\f\";\n              break;\n            case 0x28: // '('\n            case 0x29: // ')'\n            case 0x5c: // '\\'\n              str += String.fromCharCode(c);\n              break;\n            case 0x30: // 0\n            case 0x31: // 1\n            case 0x32: // 2\n            case 0x33: // 3\n            case 0x34: // 4\n            case 0x35: // 5\n            case 0x36: // 6\n            case 0x37: // 7\n            case 0x38: // 8\n            case 0x39: // 9\n              const oct = String.fromCharCode(c) + lexer.readString(2);\n              str += String.fromCharCode(parseInt(oct, 8));\n              break;\n            default:\n              lexer.shift(-1);\n              break;\n          }\n          break;\n        case 0x0d: // CR\n        case 0x0a: // LF\n          // ignore EOL characters\n          break;\n        default:\n          str += String.fromCharCode(c);\n          break;\n      }\n    }\n\n    return new PDFString(str);\n  }\n\n  static parseHex(lexer, trial) {\n    if (lexer.getString(1) !== \"<\") {\n      if (trial) {\n        return undefined;\n      }\n\n      throw new Error(\"Invalid hex string\");\n    }\n\n    lexer.shift(1);\n\n    let str = \"\";\n\n    let done = false;\n    const digits = [];\n    const addCharacter = function (force) {\n      if (digits.length !== 2) {\n        if (digits.length === 1 && force) {\n          digits.push(\"0\");\n        } else {\n          return;\n        }\n      }\n\n      str += String.fromCharCode(parseInt(digits.join(\"\"), 16));\n      digits.length = 0;\n    };\n\n    let c;\n    while (!done && (c = lexer._nextCharCode()) >= 0) {\n      switch (true) {\n        case c === 0x3e: // >\n          done = true;\n          break;\n        case c >= 0x30 && c <= 0x39: // 0 - 9\n        case c >= 0x41 && c <= 0x5a: // A - B\n        case c >= 0x61 && c <= 0x7a: // a - b\n          digits.push(String.fromCharCode(c));\n          addCharacter();\n          break;\n        case Lexer.isWhiteSpace(c):\n          break;\n        default:\n          lexer._warning(\n            \"invalid character `\" + String.fromCharCode(c) + \"` in hex string\",\n          );\n          break;\n      }\n    }\n\n    addCharacter(true);\n\n    return new PDFString(str);\n  }\n}\n\nmodule.exports = PDFString;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}