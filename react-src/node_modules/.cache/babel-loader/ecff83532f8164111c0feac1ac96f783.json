{"ast":null,"code":"\"use strict\";\n\nconst PDF = require(\"./object\");\nconst Parser = require(\"./parser/parser\");\nconst ops = require(\"./ops\");\nconst PROPERTIES_TO_COPY = {\n  colorSpaces: \"ColorSpace\",\n  fonts: \"Font\",\n  xobjects: \"XObject\",\n  extGStates: \"ExtGState\",\n  shadings: \"Shading\"\n};\nmodule.exports = class ExternalDocument {\n  constructor(src) {\n    const parser = new Parser(src);\n    parser.parse();\n    const catalog = parser.trailer.get(\"Root\").object.properties;\n    const pages = catalog.get(\"Pages\").object.properties;\n    this.pages = pages;\n    this.mediaBox = pages.get(\"MediaBox\");\n    const kids = pages.get(\"Kids\");\n    this.pageCount = this._countPagesRecursively(kids, 0);\n  }\n  _countPagesRecursively(kids, i) {\n    for (const kid of kids) {\n      const page = kid.object;\n      if (page.properties.get(\"Type\").toString() === \"/Pages\") {\n        // encountered nested pages\n        i = this._countPagesRecursively(page.properties.get(\"Kids\"), i);\n      } else {\n        i++;\n      }\n    }\n    return i;\n  }\n\n  // TODO: add mutex to not write concurrently (because of document specific _registerObject)\n  async write(doc, page) {\n    await doc._endPage();\n    const kids = this.pages.get(\"Kids\");\n    const filter = page ? i => i === page - 1 : undefined;\n    for (const page of this._iterPagesRecursively(doc, kids, filter)) {\n      // if the page object does not define its MediaBox, explicitly set its MediaBox to the\n      // value defined by its parent Pages object\n      if (!page.properties.has(\"MediaBox\") && this.mediaBox) {\n        page.properties.set(\"MediaBox\", this.mediaBox);\n      }\n\n      // add single page\n      doc._registerObject(page, true);\n\n      // first, register objects to assign IDs (for references)\n      const objects = [];\n      Parser.addObjectsRecursive(objects, page, 0);\n      for (const obj of objects) {\n        doc._registerObject(obj, true);\n      }\n\n      // write objects\n      for (const obj of objects) {\n        await doc._writeObject(obj);\n      }\n      page.prop(\"Parent\", doc._pagesObj.toReference());\n      await doc._writeObject(page);\n      doc._pages.push(page.toReference());\n    }\n  }\n  *_iterPagesRecursively(doc, kids, filter, cursor) {\n    if (!cursor) {\n      cursor = {\n        i: 0\n      };\n    }\n    for (const kid of kids) {\n      const page = kid.object;\n      if (page.properties.get(\"Type\").toString() === \"/Pages\") {\n        // encountered nested pages\n        yield* this._iterPagesRecursively(doc, page.properties.get(\"Kids\"), filter, cursor);\n        continue;\n      } else if (!filter || filter(cursor.i)) {\n        yield page;\n      }\n      cursor.i++;\n    }\n  }\n  async setAsTemplate(doc, firstPageOnly) {\n    await doc._endPage();\n\n    // take the first page only\n    const filter = i => i === 0;\n    const kids = this.pages.get(\"Kids\");\n    if (!kids[0]) {\n      throw new TypeError(\"External document is invalid\");\n    }\n\n    // Create content chunks used to save and restore the graphical state so a template cannot mess\n    // with the page's own graphical state.\n    await doc._startContentObject();\n    await doc._write(ops.q());\n    await doc._endContentObject();\n    await doc._startContentObject();\n    await doc._write(ops.Q());\n    await doc._endContentObject();\n    const [storeGraphicalState, restoreGraphicalState] = doc._contents.splice(doc._contents - 3, 2);\n    for (const page of this._iterPagesRecursively(doc, kids, filter)) {\n      // if the page object does not define its MediaBox, explicitly set its MediaBox to the\n      // value defined by its parent Pages object\n      if (!page.properties.has(\"MediaBox\") && this.mediaBox) {\n        page.properties.set(\"MediaBox\", this.mediaBox);\n      }\n      const first = page.properties;\n      const objects = [];\n      Parser.addObjectsRecursive(objects, page, 0);\n\n      // first, register objects to assign IDs (for references)\n      for (const obj of objects) {\n        doc._registerObject(obj, true);\n      }\n\n      // write objects\n      for (const obj of objects) {\n        await doc._writeObject(obj);\n      }\n      let contents = first.get(\"Contents\");\n      if (!Array.isArray(contents)) {\n        contents = [contents];\n      }\n      contents = [storeGraphicalState._object.toReference(), ...contents, restoreGraphicalState._object.toReference()];\n      let resources = first.get(\"Resources\");\n      if (resources instanceof PDF.Reference) {\n        resources = resources.object.properties;\n      }\n      doc._template = {\n        contents: contents.map(c => c && c.toString() || \"\"),\n        colorSpaces: {},\n        fonts: {},\n        xobjects: {},\n        extGStates: {},\n        shadings: {}\n      };\n      for (const prop in PROPERTIES_TO_COPY) {\n        const dict = resources && resources.get(PROPERTIES_TO_COPY[prop]);\n        if (dict) {\n          for (const alias in dict.dictionary) {\n            doc._template[prop][alias] = dict.dictionary[alias].toString();\n            doc._aliases.block(alias);\n          }\n        }\n      }\n      doc._template.firstPageOnly = firstPageOnly;\n    }\n  }\n  async _getPagesRecursively(doc, kids, i, filter) {\n    for (const kid of kids) {\n      const page = kid.object;\n      if (page.properties.get(\"Type\").toString() === \"/Pages\") {\n        // encountered nested pages\n        i = await this._addPagesRecursively(doc, page.properties.get(\"Kids\"), i, filter);\n        continue;\n      } else if (!filter || filter(i)) {\n        // if the page object does not define its MediaBox, explicitly set its MediaBox to the\n        // value defined by its parent Pages object\n        if (!page.properties.has(\"MediaBox\") && this.mediaBox) {\n          page.properties.set(\"MediaBox\", this.mediaBox);\n        }\n\n        // add single page\n        doc._registerObject(page, true);\n\n        // first, register objects to assign IDs (for references)\n        const objects = [];\n        Parser.addObjectsRecursive(objects, page, 0);\n        for (const obj of objects) {\n          doc._registerObject(obj, true);\n        }\n\n        // write objects\n        for (const obj of objects) {\n          await doc._writeObject(obj);\n        }\n        page.prop(\"Parent\", doc._pagesObj.toReference());\n        await doc._writeObject(page);\n        doc._pages.push(page.toReference());\n      }\n      i++;\n    }\n    return i;\n  }\n};","map":{"version":3,"names":["PDF","require","Parser","ops","PROPERTIES_TO_COPY","colorSpaces","fonts","xobjects","extGStates","shadings","module","exports","ExternalDocument","constructor","src","parser","parse","catalog","trailer","get","object","properties","pages","mediaBox","kids","pageCount","_countPagesRecursively","i","kid","page","toString","write","doc","_endPage","filter","undefined","_iterPagesRecursively","has","set","_registerObject","objects","addObjectsRecursive","obj","_writeObject","prop","_pagesObj","toReference","_pages","push","cursor","setAsTemplate","firstPageOnly","TypeError","_startContentObject","_write","q","_endContentObject","Q","storeGraphicalState","restoreGraphicalState","_contents","splice","first","contents","Array","isArray","_object","resources","Reference","_template","map","c","dict","alias","dictionary","_aliases","block","_getPagesRecursively","_addPagesRecursively"],"sources":["C:/xampp/htdocs/stardust/wp-content/themes/stardust-theme/react-src/node_modules/pdfjs/lib/external.js"],"sourcesContent":["\"use strict\";\n\nconst PDF = require(\"./object\");\nconst Parser = require(\"./parser/parser\");\nconst ops = require(\"./ops\");\n\nconst PROPERTIES_TO_COPY = {\n  colorSpaces: \"ColorSpace\",\n  fonts: \"Font\",\n  xobjects: \"XObject\",\n  extGStates: \"ExtGState\",\n  shadings: \"Shading\",\n};\n\nmodule.exports = class ExternalDocument {\n  constructor(src) {\n    const parser = new Parser(src);\n    parser.parse();\n\n    const catalog = parser.trailer.get(\"Root\").object.properties;\n    const pages = catalog.get(\"Pages\").object.properties;\n\n    this.pages = pages;\n    this.mediaBox = pages.get(\"MediaBox\");\n\n    const kids = pages.get(\"Kids\");\n    this.pageCount = this._countPagesRecursively(kids, 0);\n  }\n\n  _countPagesRecursively(kids, i) {\n    for (const kid of kids) {\n      const page = kid.object;\n      if (page.properties.get(\"Type\").toString() === \"/Pages\") {\n        // encountered nested pages\n        i = this._countPagesRecursively(page.properties.get(\"Kids\"), i);\n      } else {\n        i++;\n      }\n    }\n\n    return i;\n  }\n\n  // TODO: add mutex to not write concurrently (because of document specific _registerObject)\n  async write(doc, page) {\n    await doc._endPage();\n\n    const kids = this.pages.get(\"Kids\");\n    const filter = page ? (i) => i === page - 1 : undefined;\n\n    for (const page of this._iterPagesRecursively(doc, kids, filter)) {\n      // if the page object does not define its MediaBox, explicitly set its MediaBox to the\n      // value defined by its parent Pages object\n      if (!page.properties.has(\"MediaBox\") && this.mediaBox) {\n        page.properties.set(\"MediaBox\", this.mediaBox);\n      }\n\n      // add single page\n      doc._registerObject(page, true);\n\n      // first, register objects to assign IDs (for references)\n      const objects = [];\n      Parser.addObjectsRecursive(objects, page, 0);\n      for (const obj of objects) {\n        doc._registerObject(obj, true);\n      }\n\n      // write objects\n      for (const obj of objects) {\n        await doc._writeObject(obj);\n      }\n\n      page.prop(\"Parent\", doc._pagesObj.toReference());\n      await doc._writeObject(page);\n\n      doc._pages.push(page.toReference());\n    }\n  }\n\n  *_iterPagesRecursively(doc, kids, filter, cursor) {\n    if (!cursor) {\n      cursor = { i: 0 };\n    }\n\n    for (const kid of kids) {\n      const page = kid.object;\n\n      if (page.properties.get(\"Type\").toString() === \"/Pages\") {\n        // encountered nested pages\n        yield* this._iterPagesRecursively(\n          doc,\n          page.properties.get(\"Kids\"),\n          filter,\n          cursor,\n        );\n        continue;\n      } else if (!filter || filter(cursor.i)) {\n        yield page;\n      }\n\n      cursor.i++;\n    }\n  }\n\n  async setAsTemplate(doc, firstPageOnly) {\n    await doc._endPage();\n\n    // take the first page only\n    const filter = (i) => i === 0;\n    const kids = this.pages.get(\"Kids\");\n    if (!kids[0]) {\n      throw new TypeError(\"External document is invalid\");\n    }\n\n    // Create content chunks used to save and restore the graphical state so a template cannot mess\n    // with the page's own graphical state.\n    await doc._startContentObject();\n    await doc._write(ops.q());\n    await doc._endContentObject();\n    await doc._startContentObject();\n    await doc._write(ops.Q());\n    await doc._endContentObject();\n    const [storeGraphicalState, restoreGraphicalState] = doc._contents.splice(\n      doc._contents - 3,\n      2,\n    );\n\n    for (const page of this._iterPagesRecursively(doc, kids, filter)) {\n      // if the page object does not define its MediaBox, explicitly set its MediaBox to the\n      // value defined by its parent Pages object\n      if (!page.properties.has(\"MediaBox\") && this.mediaBox) {\n        page.properties.set(\"MediaBox\", this.mediaBox);\n      }\n      const first = page.properties;\n      const objects = [];\n      Parser.addObjectsRecursive(objects, page, 0);\n\n      // first, register objects to assign IDs (for references)\n      for (const obj of objects) {\n        doc._registerObject(obj, true);\n      }\n\n      // write objects\n      for (const obj of objects) {\n        await doc._writeObject(obj);\n      }\n\n      let contents = first.get(\"Contents\");\n      if (!Array.isArray(contents)) {\n        contents = [contents];\n      }\n      contents = [\n        storeGraphicalState._object.toReference(),\n        ...contents,\n        restoreGraphicalState._object.toReference(),\n      ];\n\n      let resources = first.get(\"Resources\");\n      if (resources instanceof PDF.Reference) {\n        resources = resources.object.properties;\n      }\n\n      doc._template = {\n        contents: contents.map((c) => (c && c.toString()) || \"\"),\n        colorSpaces: {},\n        fonts: {},\n        xobjects: {},\n        extGStates: {},\n        shadings: {},\n      };\n\n      for (const prop in PROPERTIES_TO_COPY) {\n        const dict = resources && resources.get(PROPERTIES_TO_COPY[prop]);\n        if (dict) {\n          for (const alias in dict.dictionary) {\n            doc._template[prop][alias] = dict.dictionary[alias].toString();\n            doc._aliases.block(alias);\n          }\n        }\n      }\n\n      doc._template.firstPageOnly = firstPageOnly;\n    }\n  }\n\n  async _getPagesRecursively(doc, kids, i, filter) {\n    for (const kid of kids) {\n      const page = kid.object;\n\n      if (page.properties.get(\"Type\").toString() === \"/Pages\") {\n        // encountered nested pages\n        i = await this._addPagesRecursively(\n          doc,\n          page.properties.get(\"Kids\"),\n          i,\n          filter,\n        );\n        continue;\n      } else if (!filter || filter(i)) {\n        // if the page object does not define its MediaBox, explicitly set its MediaBox to the\n        // value defined by its parent Pages object\n        if (!page.properties.has(\"MediaBox\") && this.mediaBox) {\n          page.properties.set(\"MediaBox\", this.mediaBox);\n        }\n\n        // add single page\n        doc._registerObject(page, true);\n\n        // first, register objects to assign IDs (for references)\n        const objects = [];\n        Parser.addObjectsRecursive(objects, page, 0);\n        for (const obj of objects) {\n          doc._registerObject(obj, true);\n        }\n\n        // write objects\n        for (const obj of objects) {\n          await doc._writeObject(obj);\n        }\n\n        page.prop(\"Parent\", doc._pagesObj.toReference());\n        await doc._writeObject(page);\n\n        doc._pages.push(page.toReference());\n      }\n\n      i++;\n    }\n\n    return i;\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}