{"ast":null,"code":"\"use strict\";\n\nconst util = require(\"../util\");\nclass PDFReference {\n  constructor(obj) {\n    Object.defineProperty(this, \"object\", {\n      enumerable: true,\n      get: () => {\n        if (!obj) {\n          return undefined;\n        }\n        if (typeof obj === \"function\") {\n          obj = obj();\n        }\n        return obj;\n      }\n    });\n  }\n  toString() {\n    return this.object.id + \" \" + this.object.rev + \" R\";\n  }\n  static parse(xref, lexer, trial) {\n    const before = lexer.pos;\n    const id = lexer.readNumber(trial);\n    if (id === undefined && !trial) {\n      throw new Error(\"Invalid indirect\");\n    }\n    lexer.skipWhitespace(1, trial);\n    const generation = lexer.readNumber(trial);\n    if (generation === undefined && !trial) {\n      throw new Error(\"Invalid indirect\");\n    }\n    lexer.skipWhitespace(1, trial);\n    if (lexer.getString(1) !== \"R\") {\n      if (trial) {\n        lexer.pos = before;\n        return undefined;\n      }\n      throw new Error(\"Invalid indirect\");\n    }\n    lexer.shift(1);\n    if (!lexer.state.references) {\n      lexer.state.references = new Map();\n    }\n    const key = `${id} ${generation}`;\n    if (lexer.state.references.has(key)) {\n      return lexer.state.references.get(key);\n    }\n    const ref = new PDFReference(parseObject.bind(null, xref, lexer.outer, id));\n    lexer.state.references.set(key, ref);\n    return ref;\n  }\n}\nmodule.exports = PDFReference;\nfunction parseObject(xref, lexer, id) {\n  const PDFObject = require(\"./object\");\n  const Lexer = require(\"../parser/lexer\");\n  const obj = xref.get(id);\n  if (obj) {\n    return obj;\n  }\n  const offset = xref.getOffset(id);\n  if (offset === null) {\n    const entry = xref.objects[id];\n    if (entry.compressed) {\n      if (!entry.obj) {\n        lexer.pos = xref.getOffset(entry.id);\n        const obj = PDFObject.parse(xref, lexer);\n        const type = obj.properties.get(\"Type\");\n        if (type && type.name !== \"ObjStm\") {\n          throw new Error(\"Expected compressed object stream\");\n        }\n        const src = util.inflate(obj);\n        // console.log(\"STRING: \", String.fromCharCode.apply(null, src))\n        const innerLexer = new Lexer(src, lexer);\n        obj.lexer = innerLexer;\n        obj.innerObjects = [];\n        const n = obj.properties.get(\"N\");\n        for (let i = 0; i < n; ++i) {\n          const id = innerLexer.readNumber(false);\n          innerLexer.skipWhitespace(null, false);\n          const offset = innerLexer.readNumber(false);\n          innerLexer.skipWhitespace(null, true);\n          obj.innerObjects.push({\n            id: id,\n            offset: offset,\n            obj: null\n          });\n        }\n        entry.obj = obj;\n      }\n      const inner = entry.obj.innerObjects[entry.ix];\n      if (!inner.obj) {\n        const innerLexer = entry.obj.lexer;\n        innerLexer.pos = entry.obj.properties.get(\"First\") + inner.offset;\n        inner.obj = PDFObject.parseInner(xref, innerLexer);\n      }\n      return inner.obj;\n    } else {\n      throw new Error(\"Expected compressed object stream\");\n    }\n  } else {\n    lexer.pos = offset;\n    return PDFObject.parse(xref, lexer);\n  }\n}","map":{"version":3,"names":["util","require","PDFReference","constructor","obj","Object","defineProperty","enumerable","get","undefined","toString","object","id","rev","parse","xref","lexer","trial","before","pos","readNumber","Error","skipWhitespace","generation","getString","shift","state","references","Map","key","has","ref","parseObject","bind","outer","set","module","exports","PDFObject","Lexer","offset","getOffset","entry","objects","compressed","type","properties","name","src","inflate","innerLexer","innerObjects","n","i","push","inner","ix","parseInner"],"sources":["C:/xampp/htdocs/stardust/wp-content/themes/stardust-theme/react-src/node_modules/pdfjs/lib/object/reference.js"],"sourcesContent":["\"use strict\";\n\nconst util = require(\"../util\");\n\nclass PDFReference {\n  constructor(obj) {\n    Object.defineProperty(this, \"object\", {\n      enumerable: true,\n      get: () => {\n        if (!obj) {\n          return undefined;\n        }\n\n        if (typeof obj === \"function\") {\n          obj = obj();\n        }\n\n        return obj;\n      },\n    });\n  }\n\n  toString() {\n    return this.object.id + \" \" + this.object.rev + \" R\";\n  }\n\n  static parse(xref, lexer, trial) {\n    const before = lexer.pos;\n\n    const id = lexer.readNumber(trial);\n    if (id === undefined && !trial) {\n      throw new Error(\"Invalid indirect\");\n    }\n\n    lexer.skipWhitespace(1, trial);\n    const generation = lexer.readNumber(trial);\n    if (generation === undefined && !trial) {\n      throw new Error(\"Invalid indirect\");\n    }\n\n    lexer.skipWhitespace(1, trial);\n    if (lexer.getString(1) !== \"R\") {\n      if (trial) {\n        lexer.pos = before;\n        return undefined;\n      }\n\n      throw new Error(\"Invalid indirect\");\n    }\n\n    lexer.shift(1);\n\n    if (!lexer.state.references) {\n      lexer.state.references = new Map();\n    }\n    const key = `${id} ${generation}`;\n    if (lexer.state.references.has(key)) {\n      return lexer.state.references.get(key);\n    }\n\n    const ref = new PDFReference(parseObject.bind(null, xref, lexer.outer, id));\n    lexer.state.references.set(key, ref);\n    return ref;\n  }\n}\n\nmodule.exports = PDFReference;\n\nfunction parseObject(xref, lexer, id) {\n  const PDFObject = require(\"./object\");\n  const Lexer = require(\"../parser/lexer\");\n\n  const obj = xref.get(id);\n  if (obj) {\n    return obj;\n  }\n\n  const offset = xref.getOffset(id);\n  if (offset === null) {\n    const entry = xref.objects[id];\n    if (entry.compressed) {\n      if (!entry.obj) {\n        lexer.pos = xref.getOffset(entry.id);\n        const obj = PDFObject.parse(xref, lexer);\n\n        const type = obj.properties.get(\"Type\");\n        if (type && type.name !== \"ObjStm\") {\n          throw new Error(\"Expected compressed object stream\");\n        }\n\n        const src = util.inflate(obj);\n        // console.log(\"STRING: \", String.fromCharCode.apply(null, src))\n        const innerLexer = new Lexer(src, lexer);\n\n        obj.lexer = innerLexer;\n        obj.innerObjects = [];\n        const n = obj.properties.get(\"N\");\n        for (let i = 0; i < n; ++i) {\n          const id = innerLexer.readNumber(false);\n          innerLexer.skipWhitespace(null, false);\n          const offset = innerLexer.readNumber(false);\n          innerLexer.skipWhitespace(null, true);\n\n          obj.innerObjects.push({\n            id: id,\n            offset: offset,\n            obj: null,\n          });\n        }\n\n        entry.obj = obj;\n      }\n\n      const inner = entry.obj.innerObjects[entry.ix];\n      if (!inner.obj) {\n        const innerLexer = entry.obj.lexer;\n        innerLexer.pos = entry.obj.properties.get(\"First\") + inner.offset;\n\n        inner.obj = PDFObject.parseInner(xref, innerLexer);\n      }\n\n      return inner.obj;\n    } else {\n      throw new Error(\"Expected compressed object stream\");\n    }\n  } else {\n    lexer.pos = offset;\n    return PDFObject.parse(xref, lexer);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}