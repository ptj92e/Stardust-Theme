{"ast":null,"code":"\"use strict\";\n\nconst PDFObject = require(\"./object\");\nconst util = require(\"../util\");\nmodule.exports = class PDFXref {\n  constructor() {\n    this.objects = [];\n    this.trailer = null;\n  }\n  add(id, data) {\n    this.objects[id] = data;\n  }\n  get(id) {\n    return this.objects[id] && this.objects[id].obj;\n  }\n  getOffset(id) {\n    return this.objects[id] && this.objects[id].offset || null;\n  }\n  toString() {\n    let xref = \"xref\\n\";\n    let range = {\n      from: 0,\n      refs: [0]\n    };\n    const ranges = [range];\n    for (let i = 1; i < this.objects.length; ++i) {\n      const obj = this.objects[i];\n      if (!obj) {\n        if (range) {\n          range = null;\n        }\n        continue;\n      }\n      if (!range) {\n        range = {\n          from: i,\n          refs: []\n        };\n        ranges.push(range);\n      }\n      range.refs.push(obj.offset);\n    }\n    ranges.forEach(function (range) {\n      xref += range.from + \" \" + range.refs.length + \"\\n\";\n      range.refs.forEach(function (ref, i) {\n        if (range.from === 0 && i === 0) {\n          xref += \"0000000000 65535 f \\n\";\n        } else {\n          xref += \"0000000000\".substr(ref.toString().length) + ref + \" 00000 n \\n\";\n        }\n      });\n    });\n    return xref;\n  }\n  static parse(_, lexer, trial) {\n    const xref = new PDFXref();\n    if (lexer.getString(4) !== \"xref\") {\n      return this.parseXrefObject(_, lexer, trial);\n    }\n    lexer.readString(4); // skip xref\n    lexer.skipSpace(null, trial);\n    lexer.skipEOL(1, trial);\n    let start;\n    while ((start = lexer.readNumber(true)) !== undefined) {\n      lexer.skipSpace(1);\n      const count = lexer.readNumber();\n      lexer.skipSpace(null, true);\n      lexer.skipEOL(1);\n      for (let i = 0, len = 0 + count; i < len; ++i) {\n        const offset = lexer.readNumber();\n        lexer.skipSpace(1);\n        lexer.readNumber(); // generation\n        lexer.skipSpace(1);\n        const key = lexer.readString(1);\n        lexer.skipSpace(null, true);\n        lexer.skipEOL(1);\n        const id = start + i;\n        if (id > 0 && key === \"n\") {\n          xref.add(id, {\n            offset: offset\n          });\n        }\n      }\n    }\n    return xref;\n  }\n\n  // TODO: this implementation needs to be improved\n  static parseXrefObject(_, lexer, trial) {\n    const xref = new PDFXref();\n    let obj;\n    try {\n      obj = PDFObject.parse(xref, lexer, trial);\n    } catch (_) {\n      throw new Error(\"Invalid xref: xref expected but not found\");\n    }\n    let kind = obj.properties.get(\"Type\");\n    if (!kind || kind.name !== \"XRef\") {\n      throw new Error(\"Invalid xref object at \" + lexer.pos);\n    }\n    const stream = util.inflate(obj);\n    xref.trailer = obj.properties;\n    const index = obj.properties.get(\"Index\");\n    const start = index ? index[0] : 0;\n    const w = obj.properties.get(\"W\");\n    const typeSize = w[0] || 1;\n    const offsetSize = w[1] || 2;\n    const genSize = w[2] || 1;\n    const len = stream.length / (typeSize + offsetSize + genSize);\n    let pos = 0;\n    for (let i = 0; i < len; ++i) {\n      const type = readUint(stream, pos, typeSize);\n      pos += typeSize;\n      const offset = readUint(stream, pos, offsetSize);\n      pos += offsetSize;\n      switch (type) {\n        case 0:\n          // free\n          pos += genSize;\n          continue;\n        // skip type 0 entries (free entries)\n        case 1:\n          // normal\n          xref.add(start + i, {\n            offset\n          });\n          pos += genSize;\n          break;\n        case 2:\n          // compressed\n          xref.add(start + i, {\n            compressed: true,\n            id: offset,\n            ix: readUint(stream, pos, genSize)\n          });\n          pos += genSize;\n          break;\n        default:\n          continue;\n      }\n    }\n    return xref;\n  }\n};\nfunction readUint(src, pos, size) {\n  let val = 0;\n  for (let i = 0; i < size; ++i) {\n    // for (let i = size - 1; i > 0; --i) {\n    val += src[pos + size - i - 1] << 8 * i;\n  }\n  return val;\n}","map":{"version":3,"names":["PDFObject","require","util","module","exports","PDFXref","constructor","objects","trailer","add","id","data","get","obj","getOffset","offset","toString","xref","range","from","refs","ranges","i","length","push","forEach","ref","substr","parse","_","lexer","trial","getString","parseXrefObject","readString","skipSpace","skipEOL","start","readNumber","undefined","count","len","key","Error","kind","properties","name","pos","stream","inflate","index","w","typeSize","offsetSize","genSize","type","readUint","compressed","ix","src","size","val"],"sources":["C:/xampp/htdocs/stardust/wp-content/themes/stardust-theme/react-src/node_modules/pdfjs/lib/object/xref.js"],"sourcesContent":["\"use strict\";\n\nconst PDFObject = require(\"./object\");\nconst util = require(\"../util\");\n\nmodule.exports = class PDFXref {\n  constructor() {\n    this.objects = [];\n    this.trailer = null;\n  }\n\n  add(id, data) {\n    this.objects[id] = data;\n  }\n\n  get(id) {\n    return this.objects[id] && this.objects[id].obj;\n  }\n\n  getOffset(id) {\n    return (this.objects[id] && this.objects[id].offset) || null;\n  }\n\n  toString() {\n    let xref = \"xref\\n\";\n\n    let range = { from: 0, refs: [0] };\n    const ranges = [range];\n\n    for (let i = 1; i < this.objects.length; ++i) {\n      const obj = this.objects[i];\n      if (!obj) {\n        if (range) {\n          range = null;\n        }\n        continue;\n      }\n\n      if (!range) {\n        range = { from: i, refs: [] };\n        ranges.push(range);\n      }\n\n      range.refs.push(obj.offset);\n    }\n\n    ranges.forEach(function (range) {\n      xref += range.from + \" \" + range.refs.length + \"\\n\";\n\n      range.refs.forEach(function (ref, i) {\n        if (range.from === 0 && i === 0) {\n          xref += \"0000000000 65535 f \\n\";\n        } else {\n          xref +=\n            \"0000000000\".substr(ref.toString().length) + ref + \" 00000 n \\n\";\n        }\n      });\n    });\n\n    return xref;\n  }\n\n  static parse(_, lexer, trial) {\n    const xref = new PDFXref();\n\n    if (lexer.getString(4) !== \"xref\") {\n      return this.parseXrefObject(_, lexer, trial);\n    }\n\n    lexer.readString(4); // skip xref\n    lexer.skipSpace(null, trial);\n    lexer.skipEOL(1, trial);\n\n    let start;\n    while ((start = lexer.readNumber(true)) !== undefined) {\n      lexer.skipSpace(1);\n      const count = lexer.readNumber();\n      lexer.skipSpace(null, true);\n      lexer.skipEOL(1);\n\n      for (let i = 0, len = 0 + count; i < len; ++i) {\n        const offset = lexer.readNumber();\n        lexer.skipSpace(1);\n        lexer.readNumber(); // generation\n        lexer.skipSpace(1);\n        const key = lexer.readString(1);\n        lexer.skipSpace(null, true);\n        lexer.skipEOL(1);\n\n        const id = start + i;\n        if (id > 0 && key === \"n\") {\n          xref.add(id, {\n            offset: offset,\n          });\n        }\n      }\n    }\n\n    return xref;\n  }\n\n  // TODO: this implementation needs to be improved\n  static parseXrefObject(_, lexer, trial) {\n    const xref = new PDFXref();\n\n    let obj;\n\n    try {\n      obj = PDFObject.parse(xref, lexer, trial);\n    } catch (_) {\n      throw new Error(\"Invalid xref: xref expected but not found\");\n    }\n\n    let kind = obj.properties.get(\"Type\");\n    if (!kind || kind.name !== \"XRef\") {\n      throw new Error(\"Invalid xref object at \" + lexer.pos);\n    }\n\n    const stream = util.inflate(obj);\n\n    xref.trailer = obj.properties;\n\n    const index = obj.properties.get(\"Index\");\n    const start = index ? index[0] : 0;\n    const w = obj.properties.get(\"W\");\n    const typeSize = w[0] || 1;\n    const offsetSize = w[1] || 2;\n    const genSize = w[2] || 1;\n    const len = stream.length / (typeSize + offsetSize + genSize);\n    let pos = 0;\n    for (let i = 0; i < len; ++i) {\n      const type = readUint(stream, pos, typeSize);\n      pos += typeSize;\n      const offset = readUint(stream, pos, offsetSize);\n      pos += offsetSize;\n      switch (type) {\n        case 0: // free\n          pos += genSize;\n          continue; // skip type 0 entries (free entries)\n        case 1: // normal\n          xref.add(start + i, {\n            offset,\n          });\n          pos += genSize;\n          break;\n        case 2: // compressed\n          xref.add(start + i, {\n            compressed: true,\n            id: offset,\n            ix: readUint(stream, pos, genSize),\n          });\n          pos += genSize;\n          break;\n        default:\n          continue;\n      }\n    }\n\n    return xref;\n  }\n};\n\nfunction readUint(src, pos, size) {\n  let val = 0;\n  for (let i = 0; i < size; ++i) {\n    // for (let i = size - 1; i > 0; --i) {\n    val += src[pos + size - i - 1] << (8 * i);\n  }\n  return val;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}